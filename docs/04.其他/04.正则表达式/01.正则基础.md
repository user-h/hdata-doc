---
title: 正则基础
date: 2022-02-27 15:35:17
permalink: /pages/e4e158/
---

## 历史

---
最初的正则表达式出现于理论计算机科学的自动控制理论和形式化语言理论中。在这些领域中有对计算（自动控制）的模型和对形式化语言描述与分类的研究。

1940年，沃伦·麦卡洛克与沃尔特·皮茨将神经系统中的神经元描述成小而简单的自动控制元。

1950年代，数学家斯蒂芬·科尔·克莱尼利用称之为“正则集合”的数学符号来描述此模型。肯·汤普逊将此符号系统引入编辑器QED，随后是Unix上的编辑器ed，并最终引入grep。自此以后，正则表达式被广泛地应用于各种Unix或类Unix系统的工具中。正则表达式的POSIX规范，分为基本型正则表达式（Basic Regular Expression，BRE）和扩展型正则表达式（Extended Regular Express，ERE）两大流派。在兼容POSIX的UNIX系统上，grep和egrep之类的工具都遵循POSIX规范，一些数据库系统中的正则表达式也匹配POSIX规范。grep、vi、sed都属于BRE，是历史最早的正则表达式，因此元字符必须转译之后才具有特殊含义。egrep、awk则属于ERE，元字符不用转译

Perl的正则表达式源自于Henry Spencer于1986年1月19日发布的regex，它已经演化成了PCRE（Perl兼容正则表达式，Perl Compatible Regular Expressions），一个由Philip Hazel开发的，为很多现代工具所使用的库。

来源：[维基百科](https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)

## POSIX规范

---
POSIX的全称是Portable Operating System Interface for unix. 分为BRE(基本型正则表达式)和ERE(扩展型正则表达式)两大流派。

**BRE流派**

Linux下的vi、grep、sed工具属于BRE这一派，BRE中元字符(、)、{、}必须转义之后才具有特殊意义，比如a\{1,2\}才能匹配字符串a或aa。

BRE不支持+、?量词，多选结构和反向引用\1、\2。

GNU对BRE做了扩展，使之支持+、?、|，但使用时需转义。也支持\1、\2之类的反向引用。

**ERE流派**

Linux下的egrep、awk属于ERE流派。这一流派中使用元字符时不用转义，支持量词等。

现在的BRE和ERE的主要差异是元字符是否需转义。

[原文链接](https://blog.csdn.net/Code_Thinking/article/details/39104135)


## 正则表达式基本语法(Perl风格?)

---
表格中使用`&#124;`作为|

| 字符 | 说明 |
| :----: | :---- |
| \ | 将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，"n"匹配字符"n"。"\n"匹配换行符。序列"\\\\"匹配"\"，"\\("匹配"("。 |
| ^ | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与"\n"或"\r"之后的位置匹配。 |
| $ | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与"\n"或"\r"之前的位置匹配。 |
| * | 零次或多次匹配前面的字符或子表达式。例如，zo* 匹配"z"和"zoo"。* 等效于 {0,}。 |
| + | 一次或多次匹配前面的字符或子表达式。例如，"zo+"与"zo"和"zoo"匹配，但与"z"不匹配。+ 等效于 {1,}。 |
| ? | 零次或一次匹配前面的字符或子表达式。例如，"do(es)?"匹配"do"或"does"中的"do"。? 等效于 {0,1}。 |
| {n} | n 是非负整数。正好匹配 n 次。例如，"o{2}"与"Bob"中的"o"不匹配，但与"food"中的两个"o"匹配。 |
| {n,} | n 是非负整数。至少匹配 n 次。例如，"o{2,}"不匹配"Bob"中的"o"，而匹配"foooood"中的所有 o。"o{1,}"等效于"o+"。"o{0,}"等效于"o*"。 |
| {n,m} | M 和 n 是非负整数，其中 n <= m。匹配至少 n 次，至多 m 次。例如，"o{1,3}"匹配"fooooood"中的头三个 o。'o{0,1}' 等效于 'o?'。注意：您不能将空格插入逗号和数字之间。 |
| ? | 当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是"非贪心的"。"非贪心的"模式匹配搜索到的、尽可能短的字符串，而默认的"贪心的"模式匹配搜索到的、尽可能长的字符串。例如，在字符串"oooo"中，"o+?"只匹配单个"o"，而"o+"匹配所有"o"。 |
| . | 匹配除"\r\n"之外的任何单个字符。若要匹配包括"\r\n"在内的任意字符，请使用诸如"[\s\S]"之类的模式。 |
| (pattern) | 匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果"匹配"集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用"\("或者"\)"。 |
| (?:pattern) | 匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用"or"字符 (&#124;) 组合模式部件的情况很有用。例如，'industr(?:y&#124;ies) 是比 'industry&#124;industries' 更经济的表达式。 |
| (?=pattern) | 执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?=95&#124;98&#124;NT&#124;2000)' 匹配"Windows 2000"中的"Windows"，但不匹配"Windows 3.1"中的"Windows"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 |
| (?!pattern) | 执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?!95&#124;98&#124;NT&#124;2000)' 匹配"Windows 3.1"中的 "Windows"，但不匹配"Windows 2000"中的"Windows"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 |
| x&#124;y | 匹配 x 或 y。例如，'z&#124;food' 匹配"z"或"food"。'(z&#124;f)ood' 匹配"zood"或"food"。 |
| [xyz] | 字符集。匹配包含的任一字符。例如，"[abc]"匹配"plain"中的"a"。 |
| [^xyz] | 反向字符集。匹配未包含的任何字符。例如，"[^abc]"匹配"plain"中"p"，"l"，"i"，"n"。 |
| [a-z] | 字符范围。匹配指定范围内的任何字符。例如，"[a-z]"匹配"a"到"z"范围内的任何小写字母。 |
| [^a-z] | 反向范围字符。匹配不在指定的范围内的任何字符。例如，"[^a-z]"匹配任何不在"a"到"z"范围内的任何字符。 |
| \b | 匹配一个字边界，即字与空格间的位置。例如，"er\b"匹配"never"中的"er"，但不匹配"verb"中的"er"。 |
| \B | 非字边界匹配。"er\B"匹配"verb"中的"er"，但不匹配"never"中的"er"。 |
| \cx | 匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是"c"字符本身。 |
| \d | 数字字符匹配。等效于 [0-9]。 |
| \D | 非数字字符匹配。等效于 [^0-9]。 |
| \f | 换页符匹配。等效于 \x0c 和 \cL。 |
| \n | 换行符匹配。等效于 \x0a 和 \cJ。 |
| \r | 匹配一个回车符。等效于 \x0d 和 \cM。 |
| \s | 匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。 |
| \S | 匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。 |
| \t | 制表符匹配。与 \x09 和 \cI 等效。 |
| \v | 垂直制表符匹配。与 \x0b 和 \cK 等效。 |
| \w | 匹配任何字类字符，包括下划线。与"[A-Za-z0-9_]"等效。 |
| \W | 与任何非单词字符匹配。与"[^A-Za-z0-9_]"等效。 |
| \xn | 匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，"\x41"匹配"A"。"\x041"与"\x04"&"1"等效。允许在正则表达式中使用 ASCII 代码。 |
| \num | 匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，"(.)\1"匹配两个连续的相同字符。 |
| \n | 标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。 |
| \nm | 标识一个八进制转义码或反向引用。如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \nm前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。 |
| \nml | 当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。 |
| \un | 匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。 |



## 匹配中文

---
参考链接：https://www.cnblogs.com/animalize/p/5432864.html

以下是比较全面的汉字Unicode分布，参考Unicode 10.0标准（2017年6月发布）：

|区块	|	范围 | 实际汉字个数/备注|  正则式 |
| :----: | :----: | :----: |:----: |
|CJK统一汉字	|	4E00-62FF, 6300-77FF,7800-8CFF, 8D00-9FFF | 20,971常见 | [\u4E00-\u9FFF] 或[一-鿆] |
|CJK统一汉字扩展A区	|	3400-4DBF | 6,582罕见  |  [\u3400-\u4DBF] |
|CJK统一汉字扩展B区	|	20000-215FF, 21600-230FF,23100-245FF, 24600-260FF,26100-275FF, 27600-290FF,29100-2A6DF | 42,711罕见，历史  |  [\U00020000-\U0002A6DF] |
|CJK统一汉字扩展C区	|	2A700-2B73F | 4,149罕见，历史  |  [\U0002A700-\U0002B73F] |
|CJK统一汉字扩展D区	|	2B740–2B81F | 222不常见，仍在使用  |  [\U0002B740-\U0002B81F] |
|CJK统一汉字扩展E区	|	2B820–2CEAF | 5,762罕见，历史  |  [\U0002B820-\U0002CEAF] |
|CJK统一汉字扩展F区	|	2CEB0-2EBEF | 7,473罕见，历史  |  [\U0002CEB0-\U0002EBEF] |
|CJK兼容汉字	|	F900–FAFF | 472重复、可统一变体、公司定义    | [\uF900-\uFAFF] |
|CJK兼容汉字增补	|	2F800-2FA1F | 542可统一变体   | [\U0002F800-\U0002FA1F] |


**★如果想表示最普遍的汉字**

用：[\u4E00-\u9FFF]  或   [一-鿆]
共有20950个汉字，包括了常用简体字和繁体字，镕等字。
基本就是GBK的所有（21003个）汉字。也包括了BIG5的所有（13053个）繁体汉字。
一般情况下这个就够用了。

> 说明：仅仅未包括出现在GBK里的CJK兼容汉字的21个汉字：郎凉秊裏隣兀嗀﨎﨏﨑﨓﨔礼﨟蘒﨡﨣﨤﨧﨨﨩
CJK兼容汉字用于转码处理，日常中是用不到的，所以不包括也没什么问题。
注意此凉非彼凉，兀也不是常用的那个，虽然用眼睛看是一样的，参见 http://www.zhihu.com/question/20697984


**★如果想表示BMP之内的汉字**

也就是Unicode值<=0xFFFF之内的所有汉字，用：[\u4E00-\u9FFF\u3400-\u4DBF\uF900-\uFAFF]，这个包含但不限于GBK定义的汉字，共有28025个汉字。

> 说明：和上面相比，主要是多了CJK统一汉字扩展A区，这是1999年收录到Unicode 3.0标准里的6,582个汉字。
CJK统一汉字扩展A区，包括了东亚各地区（陆港台日韩新越）的汉字，有很多康熙字典的繁体字。


**★ 如果想尽可能表示所有的汉字**

用：[\u4E00-\u9FFF\u3400-\u4DBF\uF900-\uFAFF\U00020000-U0002EBEF]这个包含上表的所有88342个汉字
 
>说明：
1, 以上正则表达式不会匹配（英文、汉字的）标点符号，不会匹配韩国拼音字、日本假名。
2, 会匹配一些日本、韩国独有的汉字。
3, 包含了一些没有汉字的空位置，这通常不碍事。
4, \u及\U的正则语法在Python 3.5上测试通过。
有些正则表达式引擎不认\uFFFF和\UFFFFFFFF这样的语法，可以换成\x{FFFF}试一下；有些不支持BMP之外的范围，这就没办法处理CJK统一汉字扩展B~E区了，如notepad++。

