---
title: Shell基础
date: 2022-03-10 16:49:17
permalink: /pages/5704cc/
---
## shell基础

### 命令

#### 目录操作

**1.新建目录**

```
mkdir -p -m 777 aaa/bbb/ccc.c        #当前目录下 新建目录aaa/bbb/ccc.c

选项
-m<目标属性>或--mode<目标属性>建立目录的同时设置目录的权限
-p或--parents 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录
--version 显示版本信息
-Z：设置安全上下文，当使用SELinux时有效
```


**2.删除目录**

```
rm -r bbb            #删除bbb目录及其下所有
参数
指定被删除的文件列表，如果参数中含有目录，则必须加上-r或者-R选项
选项
-d：直接把欲删除的目录的硬连接数据删除成0，删除该目录；
-f：强制删除文件或目录；
-i：删除已有文件或目录之前先询问用户；
-r或-R：递归处理，将指定目录下的所有文件与子目录一并处理；
--preserve-root：不对根目录进行递归操作；
-v：显示指令的详细执行过程。
===============================================================
rmdir    #注意：子目录被删除之前应该是空目录。就是说，该目录中的所有文件必须用rm命令全部，另外，当前工作目录必须在被删除目录之上，不能是被删除目录本身，也不能是被删除目录的子目录
参数：
目录列表：要删除的空目录列表。当删除多个空目录时，目录名之间使用空格隔开。
选项:
-p或--parents：删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除；
--ignore-fail-on-non-empty：此选项使rmdir命令忽略由于删除非空目录时导致的错误信息；
-v或-verboes：显示命令的详细执行过程；
--help：显示命令的帮助信息；
--version：显示命令的版本信息。
```

**3.复制目录**

```
cp -r ../ahb bbb        #把上一层的ahb目录 复制到当前bbb目录下
参数
源文件：制定源文件列表。默认情况下，cp命令不能复制目录，如果要复制目录，则必须使用-R选项；
目标文件：指定目标文件。当“源文件”为多个文件时，要求“目标文件”为指定的目录。
选项
-a：此参数的效果和同时指定"-dpR"参数相同；
-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；
-f：强行复制文件或目录，不论目标文件或目录是否已存在；
-i：覆盖既有文件之前先询问用户；
-l：对源文件建立硬连接，而非复制文件；
-p：保留源文件或目录的属性；
-R/r：递归处理，将指定目录下的所有文件与子目录一并处理；
-s：对源文件建立符号连接，而非复制文件；
-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；
-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；
-b：覆盖已存在的文件目标前将目标文件备份；
-v：详细显示命令执行的操作。
```

**4.移动目录**

```
mv -i ../ahb/* bbb        #把上级目录ahb下所有文件 移动到当前bbb目录下 (可用作重命名)
参数
源文件：源文件列表
目标文件：如果“目标文件”是文件名则在移动文件的同时，将其改名为“目标文件”；如果“目标文件”是目录名则将源文件移动到“目标文件”下
选项
--backup=<备份模式>：若需覆盖文件，则覆盖前先行备份；
-b：当文件存在时，覆盖前，为其创建一个备份；
-f：若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录；
-i：交互式操作，覆盖前先行询问用户，如果源文件与目标文件或目标目录中的文件同名，则询问用户是否覆盖目标文件。用户输入”y”，表示将覆盖目标文件；输入”n”，表示取消对源文件的移动。这样可以避免误将文件覆盖。
--strip-trailing-slashes：删除源文件中的斜杠“/”；
-S<后缀>：为备份文件指定后缀，而不使用默认的后缀；
--target-directory=<目录>：指定源文件要移动到目标目录；
-u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。
```


**5.touch命令**
touch命令有两个功能：一是用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来；二是用来创建新的空文件

```

参数：
文件：指定要设置时间属性的文件列表
选项：
-a：或--time=atime或--time=access或--time=use  只更改存取时间；
-c：或--no-create  不建立任何文件；
-d：<时间日期> 使用指定的日期时间，而非现在的时间；
-f：此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题；
-m：或--time=mtime或--time=modify  只更该变动时间；
-r：<参考文件或目录>  把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同；
-t：<日期时间>  使用指定的日期时间，而非现在的时间；
```

#### 文件权限

**1. 查看文件权限**
命令
```
ls -al
ll
```

**权限一共十位**
第一位 表示文件类型
```
“-” 代表普通文件（regular file）
“d” 代表目录（directory）
“l”代表连接文件
“b”代表块设备文件，及一些存储文件，如硬盘，软盘等，
“c”代表字符设备文件，即一些串行端口的接口文件，如键盘，鼠标等
“s”代表套接字（sockets 数据接口文件），这种类型的文件通常被用在网络上的数据连接，我们可以启动一个程序来监听客户端的请求，而客户端就可以通过数据接口文件来进行数据通信。
“p”代表管道（FIFO，pipe）
```

第2-4位
```
文件拥有者的w r x权限
```

第5-7位
```
文件所属组的w r x权限
```

第8-10位
```
其他组的w r x权限
```

**2. 修改文件权限 (root下)**

```
在linux系统中
r（读read权限），二进制是100，十进制是4
w（写write权限），二进制是010，十进制是2
x（执行excute权限），二进制是001，十进制是1
具备多个权限就要报4、2、1相加，所以最大的权限就是777
rwx  对应是二进制是111，十进制7
rw   对应的二进制是11 ，十进制6
```

```
chgrp 组名 文件名
chown 拥有者 文件名
chmod
    chmod xyz 文件或目录（xyz代表 拥有者 组 其他组的权限）
```

**3. umask命令**

```
umask命令用来设置限制新建文件权限的掩码。当新文件被创建时，其最初的权限由文件创建掩码决定。用户每次注册进入系统时，umask命令都被执行， 并自动设置掩码mode来限制新文件的权限。用户可以通过再次执行umask命令来改变默认值，新的权限将会把旧的覆盖掉。

选项
-p：输出的权限掩码可直接作为指令来执行；
-S：以符号方式输出权限掩码。
```

实例

```
umask u=, g=w, o=rwx            # 创建掩码，使得组用户的写权限，其他用户的读、写和执行权限都被取消
```

#### 查看文本命令

```shell script
cat  由第一行开始显示档案内容
tac  从最后一行开始显示，可以看出 tac 是 cat 的倒着写！
more 一页一页的显示档案内容
less 与 more 类似，但是比 more 更好的是，他可以往前翻页！
head 只看头几行
tail 只看尾巴几行
nl   显示的时候，顺道输出 行号！
od   以二进制的方式读取档案内容！
```

实例
**1. cat**

```
-b        #非空的行输出行号，空行会输出，但不标记行号
-n        #所有行都输出行号

cat file1.txt                                #屏幕上显示file1内容
cat file1.txt file2.txt                        #显示1 和2
cat file1.txt file2.txt>mfile.txt            #file1和file2的内容合并到mfile
```

**2. tac**
```shell script
tac file1.txt                                #从最后一行开始，倒序输出file1.txt的内容
```

**3. more 和 less**

more file1.txt
```
按一下空格则往下翻一页
按一下Enter则往下翻一行
按一下B键往上翻一页
不能往上一行一行的翻回去了
：f 可以显示文件名和现在的行数
q退出more
```

less file1.txt

```
more命令的所有按键less都支持
↑↓箭头可以实现一行一行的上下翻
PageDown/PageUp可以实现一页一页的上下翻
```

**4. nl**
```
b a #空行也输出行号
b t #默认设置
n ln ##行号最左方显示
n rn ##行号最右方显示，且不加0
n rz ##行号最右方显示，且加0
w ##设置行号字段占用的位数
```

**5. head 和 tail**
```
head file2.txt                          # 默认只显示文件的前10行文本内容
head -n 6 file2.txt                     # -n 6 参数指定显示文件的前6行
head -n -4 file2.txt                    #-n -4 负数表示除去文件结尾的4行，其他的从头开始的所有行都显示出来
```
```
tail file2.txt                          # 默认只显示从文件最后一行开始的10行文本内容
tail -n 5 file2.txt                     # -n 5 参数指定显示文件的最后5行
tail -n -5 file2.txt                    # **-n -5**tail命令不支持负数，执行结果同-n 5
```

**6. vim**


#### vim

**小范围移动光标**

```
h 或 向左箭头键(←)        #光标向左移动一个字符    也可30h或30←等
j 或 向下箭头键(↓)        #光标向下移动一个字符    也可30j或30↓等    同30 +        同30<enter>
k 或 向上箭头键(↑)        #光标向上移动一个字符    也可30k或30↑等    同30 -
l 或 向右箭头键(→)        #光标向右移动一个字符    也可30l或30→等    同30<space>
==========================================================================================
0 或功能键[Home]          #这是数字『 0 』：移动到这一列的最前面字符处 (常用)
$ 或功能键[End]           #移动到这一列的最后面字符处(常用)
==========================================================================================
H                        #光标移动到这个屏幕的最上方那一列的第一个字符 
M                        #光标移动到这个屏幕的中央那一列的第一个字符 
L                        #光标移动到这个屏幕的最下方那一列的第一个字符
```

**换页**

```
[Ctrl] + [f]             #屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)
[Ctrl] + [b]             #屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)
[Ctrl] + [d]             #屏幕『向下』移动半页 
[Ctrl] + [u]             #屏幕『向上』移动半页 
```

**跳页**

```
G                        #移动到这个文件的最后一列(常用)
gg                       #移动到这个文件的第一列，相当于 1G 啊！ (常用)
nG                       #n为数字。移动到这个文件的第 n 列。例如 20G 则会移动到这个文件的第 20 列(可配合 :set nu)
```

**搜素与替换**

```
/word                    #向光标之下寻找一个名称为 word 的字符串。例如要在文件内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) 
?word                    #向光标之上寻找一个字符串名称为 word 的字符串
n                        #这个 n 是英文按键。代表『重复前一个搜寻的动作』
N                        #与 n 刚好相反，为『反向』进行前一个搜寻动作

:n1,n2s/word1/word2/g    #n1 与 n2 为数字。在第 n1 与 n2 列之间寻找 word1 这个字符串，并将该字符串取代为 word2 (常用) 
:1,$s/word1/word2/g      #从第一列到最后一列寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)
:1,$s/word1/word2/gc     #从第一列到最后一列寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)
```

**删除、复制与粘贴**

```
u        #复原前一个动作。(常用)
[Ctrl]+r #重做上一个动作。(常用)   （等同于 .    #重复前一个动作）???

x        # x为向后删除一个字符 (相当于 [del] 按键)               也可用作20x
X        # X为向前删除一个字符([backspace] 亦即是退格键)         也可用作20X
dd       # 删除游标所在的那一整列(常用)                          也可用作20dd
d1G      # 删除光标所在到第一列的所有数据
dG       # 删除光标所在到最后一列的所有数据
d$       # 删除游标所在处，到该列的最后一个字符
d0       # 那个是数字的 0 ，删除游标所在处，到该列的最前面一个字符
=========================================================================================================
yy       # 复制游标所在的那一列(常用)                    也可用作20yy(常用)
y1G      # 复制光标所在列到第一列的所有数据 
yG       # 复制光标所在列到最后一列的所有数据 
y0       # 复制光标所在的那个字符到该列行首的所有数据 
y$       # 复制光标所在的那个字符到该列行尾的所有数据
=========================================================================================================
p, P     # p 为将已复制的数据在光标下一列贴上，P 则为贴在游标上一列！ 举例来说，我目前光标在第 20 列，且已经复制了 10 列数据。则按下 p 后， 那 10 列数据会贴在原本的 20 列之后，亦即由 21 列开始贴。但如果是按下 P 呢？ 那么原本的第 20 列会被推到变成 30 列。 (常用) 
=========================================================================================================
J        # 将光标所在列与下一列的数据结合成同一列        （删除回车？？？？）
c        # 重复删除多个数据，例如向下删除 10 列，[ 10cj ] 
```

#### find

语法
```shell script
find path -option [ -print ]   [ -exec -ok command ]   {} \;
```

实例
```shell script
### 使用inode删除文件
# 用stat 或者ls -il 。带有 -i 参数的ls命令，就是指显示文件的inode。
find . -inum [inode数字] -exec rm -i {} /;
# 将当前目录及其子目录下所有文件后缀为 .c 的文件列出来:
find . -name "*.c"
# 将当前目录及其子目录中的所有文件列出：
find . -type f
# 将当前目录及其子目录下所有最近 20 天内更新过的文件列出:
find . -ctime -20
# 查找 /var/log 目录中更改时间在 7 日以前的普通文件，并在删除之前询问它们：
find /var/log -type f -mtime +7 -ok rm {} \;
# 查找当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：
find . -type f -perm 644 -exec ls -l {} \;
# 查找系统中所有文件长度为 0 的普通文件，并列出它们的完整路径：
find / -type f -size 0 -exec ls -l {} \;
```

#### sort

对文本内容以行为单位进行排序。
**语法** `sort [-bcdfimMnr][-o<输出文件>][-t<分隔字符>][+<起始栏位>-<结束栏位>][--help][--verison][文件][-k field1[,field2]]`

**参数说明**

```language
-b 忽略每行前面开始出的空格字符。
-c 检查文件是否已经按照顺序排序。
-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。
-f 排序时，将小写字母视为大写字母。
-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。
-m 将几个排序好的文件进行合并。
-M 将前面3个字母依照月份的缩写进行排序。
-n 依照数值的大小排序。
-u 意味着是唯一的(unique)，输出的结果是去完重了的。
-o<输出文件> 将排序后的结果存入指定的文件。
-r 以相反的顺序来排序。
-t<分隔字符> 指定排序时所用的栏位分隔字符。
+<起始栏位>-<结束栏位> 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。
--help 显示帮助。
--version 显示版本信息。
[-k field1[,field2]] 按指定的列进行排序。
```

#### comm

Linux comm 命令用于比较两个**已排过序**的文件。

> 这项指令会一列列地比较两个已排序文件的差异，并将其结果显示出来，如果没有指定任何参数，则会把结果分成 3 列显示：第 1 列仅是在第 1 个文件中出现过的列，第 2 列是仅在第 2 个文件中出现过的列，第 3 列则是在第 1 与第 2 个文件里都出现过的列。若给予的文件名称为 - ，则 comm 指令会从标准输入设备读取数据。

**语法** `comm [-123][--help][--version][第1个文件][第2个文件]`

**参数说明**

```language
-1 不显示只在第 1 个文件里出现过的列。
-2 不显示只在第 2 个文件里出现过的列。
-3 不显示只在第 1 和第 2 个文件里出现过的列。
--help 在线帮助。
--version 显示版本信息。
```

#### cut

Linux cut命令用于显示每行从开头算起 num1 到 num2 的文字。

> cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。
> 如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。

**语法** 
```language
cut [-bn] [file]
cut [-c] [file]
cut [-df] [file]
```

**参数说明**
```language
-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。
-c ：以字符为单位进行分割。
-d ：自定义分隔符，默认为制表符。
-f ：与-d一起使用，指定显示哪个区域。
-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除
```

#### ps

Linux ps （英文全拼：process status）命令用于显示当前进程的状态，类似于 windows 的任务管理器。

**语法** `ps [options] [--help]`

**参数说明**
```language
ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义
-A 列出所有的进程
-w 显示加宽可以显示较多的资讯
-au 显示较详细的资讯
-aux 显示所有包含其他使用者的行程

	au(x) 输出格式 :

	USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
	USER: 行程拥有者
	PID: pid
	%CPU: 占用的 CPU 使用率
	%MEM: 占用的记忆体使用率
	VSZ: 占用的虚拟记忆体大小
	RSS: 占用的记忆体大小
	TTY: 终端的次要装置号码 (minor device number of tty)
	STAT: 该行程的状态:
		D: 无法中断的休眠状态 (通常 IO 的进程)
		R: 正在执行中
		S: 静止状态
		T: 暂停执行
		Z: 不存在但暂时无法消除
		W: 没有足够的记忆体分页可分配
		<: 高优先序的行程
		N: 低优先序的行程
		L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)
	START: 行程开始时间
	TIME: 执行的时间
	COMMAND:所执行的指令
```

#### grep

Linux grep 命令用于查找文件里符合条件的字符串。

> grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。

**语法** `grep [-abcEFGhHilLnqrsvVwxy][-A<显示行数>][-B<显示列数>][-C<显示列数>][-d<进行动作>][-e<范本样式>][-f<范本文件>][--help][范本样式][文件或目录...]`

**参数说明**
```language
-a 或 --text : 不要忽略二进制的数据。
-A<显示行数> 或 --after-context=<显示行数> : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。
-b 或 --byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。
-B<显示行数> 或 --before-context=<显示行数> : 除了显示符合样式的那一行之外，并显示该行之前的内容。
-c 或 --count : 计算符合样式的列数。
-C<显示行数> 或 --context=<显示行数>或-<显示行数> : 除了显示符合样式的那一行之外，并显示该行之前后的内容。
-d <动作> 或 --directories=<动作> : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。
-e<范本样式> 或 --regexp=<范本样式> : 指定字符串做为查找文件内容的样式。
-E 或 --extended-regexp : 将样式为延伸的正则表达式来使用。
-f<规则文件> 或 --file=<规则文件> : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。
-F 或 --fixed-regexp : 将样式视为固定字符串的列表。
-G 或 --basic-regexp : 将样式视为普通的表示法来使用。
-h 或 --no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。
-H 或 --with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。
-i 或 --ignore-case : 忽略字符大小写的差别。
-l 或 --file-with-matches : 列出文件内容符合指定的样式的文件名称。
-L 或 --files-without-match : 列出文件内容不符合指定的样式的文件名称。
-n 或 --line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。
-o 或 --only-matching : 只显示匹配PATTERN 部分。
-q 或 --quiet或--silent : 不显示任何信息。
-r 或 --recursive : 此参数的效果和指定"-d recurse"参数相同。
-s 或 --no-messages : 不显示错误信息。
-v 或 --invert-match : 显示不包含匹配文本的所有行。
-V 或 --version : 显示版本信息。
-w 或 --word-regexp : 只显示全字符合的列。
-x --line-regexp : 只显示全列符合的列。
-y : 此参数的效果和指定"-i"参数相同。
```


#### awk

AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。

> 之所以叫 AWK 是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。

**语法**
```language
awk [选项参数] 'script' var=value file(s)
或
awk [选项参数] -f scriptfile var=value file(s)
```

**参数说明**
```language
-F fs or --field-separator fs
指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。

-v var=value or --asign var=value
赋值一个用户定义变量。

-f scripfile or --file scriptfile
从脚本文件中读取awk命令。

-mf nnn and -mr nnn
对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。

-W compact or --compat, -W traditional or --traditional
在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。

-W copyleft or --copyleft, -W copyright or --copyright
打印简短的版权信息。

-W help or --help, -W usage or --usage
打印全部awk选项和每个选项的简短说明。

-W lint or --lint
打印不能向传统unix平台移植的结构的警告。

-W lint-old or --lint-old
打印关于不能向传统unix平台移植的结构的警告。

-W posix
打开兼容模式。但有以下限制，不识别：/x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符**和**=不能代替^和^=；fflush无效。

-W re-interval or --re-inerval
允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。

-W source program-text or --source program-text
使用program-text作为源代码，可与-f命令混用。

-W version or --version
打印bug报告信息的版本。
```

#### xargs

xargs（英文全拼： eXtended ARGuments）是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。

xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。

xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。

xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。

xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。

之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令，例如：
```language
find /sbin -perm +700 |ls -l       #这个命令是错误的
find /sbin -perm +700 |xargs ls -l   #这样才是正确的

ps -ef|grep java|grep -v grep|awk '{print $2}'|xargs kill  # 批量杀死进程
```

**语法**
```language
somecommand |xargs -item  command
```

**参数说明**
```language
-a file 从文件中读入作为 stdin
-e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。
-p 当每次执行一个argument的时候询问一次用户。
-n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。
-t 表示先打印命令，然后再执行。
-i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给 {}，可以用 {} 代替。
-r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。
-s num 命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。
-L num 从标准输入一次读取 num 行送给 command 命令。
-l 同 -L。
-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。
-x exit的意思，主要是配合-s使用。。
-P 修改最大的进程数，默认是1，为0时候为as many as it can ，这个例子我没有想到，应该平时都用不到的吧。
```

#### kill

Linux kill 命令用于删除执行中的程序或工作。

> kill 可将指定的信息送至程序。预设的信息为 SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用 SIGKILL(9) 信息尝试强制删除程序。程序或工作的编号可利用 ps 指令或 jobs 指令查看。

**语法** `kill [-s <信息名称或编号>][程序]　或　kill [-l <信息编号>]`

**参数说明**
```language
-l <信息编号> 　若不加<信息编号>选项，则 -l 参数会列出全部的信息名称。
-s <信息名称或编号> 　指定要送出的信息。
[程序] 　[程序]可以是程序的PID或是PGID，也可以是工作编号。

使用 kill -l 命令列出所有可用信号。
	最常用的信号是：
	1 (HUP)：重新加载进程。
	9 (KILL)：杀死一个进程。
	15 (TERM)：正常停止一个进程。
```

#### killall

Linux killall 用于杀死一个进程，与 kill 不同的是它会杀死指定名字的所有进程。

> kill 命令杀死指定进程 PID，需要配合 ps 使用，而 killall 直接对进程对名字进行操作，更加方便。

**语法** `killall [选项]  name`

**参数说明**
```language
name ： 进程名
选项包含如下几个参数：
-e | --exact ： 进程需要和名字完全相符
-I | --ignore-case ：忽略大小写
-g | --process-group ：结束进程组
-i | --interactive ：结束之前询问
-l | --list ：列出所有的信号名称
-q | --quite ：进程没有结束时，不输出任何信息
-r | --regexp ：将进程名模式解释为扩展的正则表达式。
-s | --signal ：发送指定信号
-u | --user ：结束指定用户的进程
-v | --verbose ：显示详细执行过程
-w | --wait ：等待所有的进程都结束
-V |--version ：显示版本信息
--help ：显示帮助信息
```

#### sed

Linux sed 命令是利用脚本来处理文本文件。

> sed 可依照脚本的指令来处理、编辑文本文件。    
> Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。    

**语法** `sed [-hnV][-e<script>][-f<script文件>][文本文件]`

**参数说明**
```language
-e<script>或--expression=<script> 以选项中指定的script来处理输入的文本文件。
-f<script文件>或--file=<script文件> 以选项中指定的script文件来处理输入的文本文件。
-h或--help 显示帮助。
-n或--quiet或--silent 仅显示script处理后的结果。
-V或--version 显示版本信息。
```

**动作说明**
```language
a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
d ：删除，因为是删除啊，所以 d 后面通常不接任何东东；
i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～
s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！
```

#### tar

Linux tar（英文全拼：tape archive ）命令用于备份文件。

> tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。

**语法**
```language
tar [-ABcdgGhiklmMoOpPrRsStuUvwWxzZ][-b <区块数目>][-C <目的目录>][-f <备份文件>][-F <Script文件>][-K <文件>][-L <媒体容量>][-N <日期时间>][-T <范本文件>][-V <卷册名称>][-X <范本文件>][-<设备编号><存储密度>][--after-date=<日期时间>][--atime-preserve][--backuup=<备份方式>][--checkpoint][--concatenate][--confirmation][--delete][--exclude=<范本样式>][--force-local][--group=<群组名称>][--help][--ignore-failed-read][--new-volume-script=<Script文件>][--newer-mtime][--no-recursion][--null][--numeric-owner][--owner=<用户名称>][--posix][--erve][--preserve-order][--preserve-permissions][--record-size=<区块数目>][--recursive-unlink][--remove-files][--rsh-command=<执行指令>][--same-owner][--suffix=<备份字尾字符串>][--totals][--use-compress-program=<执行指令>][--version][--volno-file=<编号文件>][文件或目录...]
```

**参数**

```language
-A或--catenate 新增文件到已存在的备份文件。
-b<区块数目>或--blocking-factor=<区块数目> 设置每笔记录的区块数目，每个区块大小为12Bytes。
-B或--read-full-records 读取数据时重设区块大小。
-c或--create 建立新的备份文件。
-C<目的目录>或--directory=<目的目录> 切换到指定的目录。
-d或--diff或--compare 对比备份文件内和文件系统上的文件的差异。
-f<备份文件>或--file=<备份文件> 指定备份文件。
-F<Script文件>或--info-script=<Script文件> 每次更换磁带时，就执行指定的Script文件。
-g或--listed-incremental 处理GNU格式的大量备份。
-G或--incremental 处理旧的GNU格式的大量备份。
-h或--dereference 不建立符号连接，直接复制该连接所指向的原始文件。
-i或--ignore-zeros 忽略备份文件中的0 Byte区块，也就是EOF。
-k或--keep-old-files 解开备份文件时，不覆盖已有的文件。
-K<文件>或--starting-file=<文件> 从指定的文件开始还原。
-l或--one-file-system 复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。
-L<媒体容量>或-tape-length=<媒体容量> 设置存放每体的容量，单位以1024 Bytes计算。
-m或--modification-time 还原文件时，不变更文件的更改时间。
-M或--multi-volume 在建立，还原备份文件或列出其中的内容时，采用多卷册模式。
-N<日期格式>或--newer=<日期时间> 只将较指定日期更新的文件保存到备份文件里。
-o或--old-archive或--portability 将资料写入备份文件时使用V7格式。
-O或--stdout 把从备份文件里还原的文件输出到标准输出设备。
-p或--same-permissions 用原来的文件权限还原文件。
-P或--absolute-names 文件名使用绝对名称，不移除文件名称前的"/"号。
-r或--append 新增文件到已存在的备份文件的结尾部分。
-R或--block-number 列出每个信息在备份文件中的区块编号。
-s或--same-order 还原文件的顺序和备份文件内的存放顺序相同。
-S或--sparse 倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。
-t或--list 列出备份文件的内容。
-T<范本文件>或--files-from=<范本文件> 指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。
-u或--update 仅置换较备份文件内的文件更新的文件。
-U或--unlink-first 解开压缩文件还原文件之前，先解除文件的连接。
-v或--verbose 显示指令执行过程。
-V<卷册名称>或--label=<卷册名称> 建立使用指定的卷册名称的备份文件。
-w或--interactive 遭遇问题时先询问用户。
-W或--verify 写入备份文件后，确认文件正确无误。
-x或--extract或--get 从备份文件中还原文件。
-X<范本文件>或--exclude-from=<范本文件> 指定范本文件，其内含有一个或多个范本样式，让ar排除符合设置条件的文件。
-z或--gzip或--ungzip 通过gzip指令处理备份文件。
-Z或--compress或--uncompress 通过compress指令处理备份文件。
-<设备编号><存储密度> 设置备份用的外围设备编号及存放数据的密度。
--after-date=<日期时间> 此参数的效果和指定"-N"参数相同。
--atime-preserve 不变更文件的存取时间。
--backup=<备份方式>或--backup 移除文件前先进行备份。
--checkpoint 读取备份文件时列出目录名称。
--concatenate 此参数的效果和指定"-A"参数相同。
--confirmation 此参数的效果和指定"-w"参数相同。
--delete 从备份文件中删除指定的文件。
--exclude=<范本样式> 排除符合范本样式的文件。
--group=<群组名称> 把加入设备文件中的文件的所属群组设成指定的群组。
--help 在线帮助。
--ignore-failed-read 忽略数据读取错误，不中断程序的执行。
--new-volume-script=<Script文件> 此参数的效果和指定"-F"参数相同。
--newer-mtime 只保存更改过的文件。
--no-recursion 不做递归处理，也就是指定目录下的所有文件及子目录不予处理。
--null 从null设备读取文件名称。
--numeric-owner 以用户识别码及群组识别码取代用户名称和群组名称。
--owner=<用户名称> 把加入备份文件中的文件的拥有者设成指定的用户。
--posix 将数据写入备份文件时使用POSIX格式。
--preserve 此参数的效果和指定"-ps"参数相同。
--preserve-order 此参数的效果和指定"-A"参数相同。
--preserve-permissions 此参数的效果和指定"-p"参数相同。
--record-size=<区块数目> 此参数的效果和指定"-b"参数相同。
--recursive-unlink 解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。
--remove-files 文件加入备份文件后，就将其删除。
--rsh-command=<执行指令> 设置要在远端主机上执行的指令，以取代rsh指令。
--same-owner 尝试以相同的文件拥有者还原文件。
--suffix=<备份字尾字符串> 移除文件前先行备份。
--totals 备份文件建立后，列出文件大小。
--use-compress-program=<执行指令> 通过指定的指令处理备份文件。
--version 显示版本信息。
--volno-file=<编号文件> 使用指定文件内的编号取代预设的卷册编号。
```

#### zip

**语法**
```language
zip [-AcdDfFghjJKlLmoqrSTuvVwXyz$][-b <工作目录>][-ll][-n <字尾字符串>][-t <日期时间>][-<压缩效率>][压缩文件][文件...][-i <范本样式>][-x <范本样式>]
```
<span style='color: red;'>注意：打包目录一定要加参数r `zip -qr xxx`</span>

**参数**
```language
-A 调整可执行的自动解压缩文件。
-b<工作目录> 指定暂时存放文件的目录。
-c 替每个被压缩的文件加上注释。
-d 从压缩文件内删除指定的文件。
-D 压缩文件内不建立目录名称。
-f 更新现有的文件。
-F 尝试修复已损坏的压缩文件。
-g 将文件压缩后附加在既有的压缩文件之后，而非另行建立新的压缩文件。
-h 在线帮助。
-i<范本样式> 只压缩符合条件的文件。
-j 只保存文件名称及其内容，而不存放任何目录名称。
-J 删除压缩文件前面不必要的数据。
-k 使用MS-DOS兼容格式的文件名称。
-l 压缩文件时，把LF字符置换成LF+CR字符。
-ll 压缩文件时，把LF+CR字符置换成LF字符。
-L 显示版权信息。
-m 将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中。
-n<字尾字符串> 不压缩具有特定字尾字符串的文件。
-o 以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同。
-q 不显示指令执行过程。
-r 递归处理，将指定目录下的所有文件和子目录一并处理。
-S 包含系统和隐藏文件。
-t<日期时间> 把压缩文件的日期设成指定的日期。
-T 检查备份文件内的每个文件是否正确无误。
-u 与 -f 参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中。
-v 显示指令执行过程或显示版本信息。
-V 保存VMS操作系统的文件属性。
-w 在文件名称里假如版本编号，本参数仅在VMS操作系统下有效。
-x<范本样式> 压缩时排除符合条件的文件。
-X 不保存额外的文件属性。
-y 直接保存符号连接，而非该连接所指向的文件，本参数仅在UNIX之类的系统下有效。
-z 替压缩文件加上注释。
-$ 保存第一个被压缩文件所在磁盘的卷册名称。
-<压缩效率> 压缩效率是一个介于1-9的数值。
```

#### unzip

**语法** `unzip [-cflptuvz][-agCjLMnoqsVX][-P <密码>][.zip文件][文件][-d <目录>][-x <文件>] 或 unzip [-Z]`

**参数**

```language
-c 将解压缩的结果显示到屏幕上，并对字符做适当的转换。
-f 更新现有的文件。
-l 显示压缩文件内所包含的文件。
-p 与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换。
-t 检查压缩文件是否正确。
-u 与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中。
-v 执行是时显示详细的信息。
-z 仅显示压缩文件的备注文字。
-a 对文本文件进行必要的字符转换。
-b 不要对文本文件进行字符转换。
-C 压缩文件中的文件名称区分大小写。
-j 不处理压缩文件中原有的目录路径。
-L 将压缩文件中的全部文件名改为小写。
-M 将输出结果送到more程序处理。
-n 解压缩时不要覆盖原有的文件。
-o 不必先询问用户，unzip执行后覆盖原有文件。
-P<密码> 使用zip的密码选项。
-q 执行时不显示任何信息。
-s 将文件名中的空白字符转换为底线字符。
-V 保留VMS的文件版本信息。
-X 解压缩时同时回存文件原来的UID/GID。
[.zip文件] 指定.zip压缩文件。
[文件] 指定要处理.zip压缩文件中的哪些文件。
-d<目录> 指定文件解压缩后所要存储的目录。
-x<文件> 指定不要处理.zip压缩文件中的哪些文件。
-Z unzip -Z等于执行zipinfo指令。
```

#### gzip

**语法**
```language
gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][--best/fast][文件...] 或 gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][--best/fast][目录]
```

**参数**
```language
-a或--ascii 　使用ASCII文字模式。
-c或--stdout或--to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。
-d或--decompress或----uncompress 　解开压缩文件。
-f或--force 　强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。
-h或--help 　在线帮助。
-l或--list 　列出压缩文件的相关信息。
-L或--license 　显示版本与版权信息。
-n或--no-name 　压缩文件时，不保存原来的文件名称及时间戳记。
-N或--name 　压缩文件时，保存原来的文件名称及时间戳记。
-q或--quiet 　不显示警告信息。
-r或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。
-S<压缩字尾字符串>或----suffix<压缩字尾字符串> 　更改压缩字尾字符串。
-t或--test 　测试压缩文件是否正确无误。
-v或--verbose 　显示指令执行过程。
-V或--version 　显示版本信息。
-<压缩效率> 　压缩效率是一个介于1－9的数值，预设值为"6"，指定愈大的数值，压缩效率就会愈高。
--best 　此参数的效果和指定"-9"参数相同。
--fast 　此参数的效果和指定"-1"参数相同。
```

#### gunzip

**语法**
```language
gunzip [-acfhlLnNqrtvV][-s <压缩字尾字符串>][文件...] 或 gunzip [-acfhlLnNqrtvV][-s <压缩字尾字符串>][目录]
```

**参数**
```language
-a或--ascii 　使用ASCII文字模式。
-c或--stdout或--to-stdout 　把解压后的文件输出到标准输出设备。
-f或-force 　强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接。
-h或--help 　在线帮助。
-k或--keep 　保留原始压缩文件。
-l或--list 　列出压缩文件的相关信息。
-L或--license 　显示版本与版权信息。
-n或--no-name 　解压缩时，若压缩文件内含有远来的文件名称及时间戳记，则将其忽略不予处理。
-N或--name 　解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上。
-q或--quiet 　不显示警告信息。
-r或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。
-S<压缩字尾字符串>或--suffix<压缩字尾字符串> 　更改压缩字尾字符串。
-t或--test 　测试压缩文件是否正确无误。
-v或--verbose 　显示指令执行过程。
-V或--version 显示版本信息。
```


#### crontab

Linux crontab 是用来定期执行程序的命令。

当安装完成操作系统之后，默认便会启动此任务调度命令。

crond 命令每分钟会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。

**注意：新创建的 cron 任务，不会马上执行，至少要过 2 分钟后才可以，当然你可以重启 cron 来马上执行。**

而 linux 任务调度的工作主要分为以下两类：

1、系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存
2、个人执行的工作：某个用户定期要做的工作，例如每隔 10 分钟检查邮件服务器是否有新信，这些工作可由每个用户自行设置

**语法**
```language
crontab [ -u user ] file
或
crontab [ -u user ] { -l | -r | -e }
```

**参数**

```language
-e : 执行文字编辑器来设定时程表，内定的文字编辑器是 VI，如果你想用别的文字编辑器，则请先设定 VISUAL 环境变数来指定使用那个文字编辑器(比如说 setenv VISUAL joe)
-r : 删除目前的时程表
-l : 列出目前的时程表
```

**时间格式**

```language
f1 f2 f3 f4 f5 program
其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。
当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其馀类推
当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推
当 f1 为 */n 时表示每 n 分钟个时间间隔执行一次，f2 为 */n 表示每 n 小时个时间间隔执行一次，其馀类推
当 f1 为 a, b, c,... 时表示第 a, b, c,... 分钟要执行，f2 为 a, b, c,... 时表示第 a, b, c...个小时要执行，其馀类推


*    *    *    *    *
-    -    -    -    -
|    |    |    |    |
|    |    |    |    +----- 星期中星期几 (0 - 6) (星期天 为0)
|    |    |    +---------- 月份 (1 - 12) 
|    |    +--------------- 一个月中的第几天 (1 - 31)
|    +-------------------- 小时 (0 - 23)
+------------------------- 分钟 (0 - 59)
```

#### free
#### top
#### du

#### chmod
#### chown
#### chgrp
#### useradd
#### usermod
#### userdel
#### groupadd
#### groupdel
#### passwd
#### groups

#### ssh
#### scp
#### stat


## shell脚本相关

#### 脚本格式

1. 以`#!/bin/bash`开头。
2. 使用sh/bash + 脚本不需要执行权限，直接使用脚本绝对路径或相对路径需要执行权限。

#### 变量类型

1. 定义变量：`变量=值` （中间不能有空格）
2. 撤销变量：unset 变量名
3. 声明静态变量：readonly变量（不能unset）

|   --  |  -- |
|  :----:  | :----  |
| global  | 作用域从定义到shell结束或者变量被删除 |
| local  | 作用域只在函数内部,函数参数是local的 |
 
#### if条件

**IF条件只能为命令（或脚本）返回值（比如./test.sh），[命令等同于test命令**

|  --   | --  |
|  ----  | ----  |
| []和test  | 在命令行里test expr和[ expr ]的效果相同(判断文件、判断字符串、判断整数) |
| 是否为文件  | if [ -f "" ] |
| 字符串长度非0  | if [ -n "" ] |
| 是否为目录  | if [ -d "" ] |
| 扩展 | https://www.cnblogs.com/pugang/p/13167714.html |
| | |
| [[ ]] | 内置在shell中的一个命令（支持字符串的模式匹配、逻辑组合可以不使用test的-a,-o而使用&& ||） |
| ~正则匹配  | if [[ $line =~ ^java\.library\.path=(.*)$ ]] |

**[] 和 [[]]的区别**
> 注意：使用[]和[[]]的时候不要吝啬空格，每一项两边都要有空格，[[ 1 == 2 ]]的结果为“假”，但[[ 1==2 ]]的结果为“真”！ 

> 1.首先，尽管很相似，但是从概念上讲，二者是不同层次的东西。"[["，是关键字，许多shell(如ash bsh)并不支持这种方式。ksh, bash(据说从2.02起引入对[[的支持)等支持。"["是一条命令， 与test等价，大多数shell都支持。在现代的大多数sh实现中，"["与"test"是内部(builtin)命令，换句话说执行"test"/"["时不会调用/some/path/to/test这样的外部命令(如果有这样的命令的话)。

> 2.[[]]结构比Bash版本的[]更通用。在[[和]]之间的所有的字符都不会被文件扩展或是标记分割，但是会有参数引用和命令替换。
用[[ ... ]]测试结构比用[ ... ]更能防止脚本里的许多逻辑错误。比如说，&&,||,<和>操作符能在一个[[]]测试里通过，但在[]结构会发生错误。

> 3.(( ))结构扩展并计算一个算术表达式的值。如果表达式值为0，会返回1或假作为退出状态码。一个非零值的表达式返回一个0或真作为退出状态码。这个结构和先前test命令及[]结构的讨论刚好相反。

> 4.[ ... ]为shell命令，所以在其中的表达式应是它的命令行参数，所以串比较操作符">" 与"<"必须转义，否则就变成IO改向操作符了(请参看上面2中的例子)。在[[中"<"与">"不需转义；
由于"[["是关键字，不会做命令行扩展，因而相对的语法就稍严格些。例如
在[ ... ]中可以用引号括起操作符，因为在做命令行扩展时会去掉这些引号，而在[[ ... ]]则不允许这样做。

> 5.[[ ... ]]进行算术扩展，而[ ... ]不做

> 6.[[ ... && ... && ... ]] 和 [ ... -a ... -a ...] 不一样，[[ ]] 是逻辑短路操作，而 [ ] 不会进行逻辑短路

#### 特殊变量

|  --   | --  |
|  ----  | ----  |
|  $'\n' | 获取换行符 |
|  $$ | Shell本身的PID（ProcessID） |
|  $! | Shell最后运行的后台Process的PID |
|  $? | 最后运行的命令的结束代码（返回值） |
|  $- | 使用Set命令设定的Flag一览 |
|  $* | 所有参数列表。如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数 |
|  $@ | 所有参数列表。如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数 |
|  $# | 添加到Shell的参数个数 |
|  $0 | Shell本身的文件名 |
|  $1～$n | 添加到Shell的各参数值。$1是第1参数、$2是第2参数… |
|  shift | 位置参数可以用shift命令左移。比如shift 3表示原来的$4现在变成$1，原来的$5现在变成$2等等，原来的$1、$2、$3丢弃，$0不移动。不带参数的shift命令相当于shift 1。 |

#### 流程控制（待补充）