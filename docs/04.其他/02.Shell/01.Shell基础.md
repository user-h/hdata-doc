---
title: Shell基础
date: 2022-03-10 16:49:17
permalink: /pages/5704cc/
---
## shell基础

### 命令

#### 目录操作

**1.新建目录**

```
mkdir -p -m 777 aaa/bbb/ccc.c        #当前目录下 新建目录aaa/bbb/ccc.c

选项
-m<目标属性>或--mode<目标属性>建立目录的同时设置目录的权限
-p或--parents 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录
--version 显示版本信息
-Z：设置安全上下文，当使用SELinux时有效
```


**2.删除目录**

```
rm -r bbb            #删除bbb目录及其下所有
参数
指定被删除的文件列表，如果参数中含有目录，则必须加上-r或者-R选项
选项
-d：直接把欲删除的目录的硬连接数据删除成0，删除该目录；
-f：强制删除文件或目录；
-i：删除已有文件或目录之前先询问用户；
-r或-R：递归处理，将指定目录下的所有文件与子目录一并处理；
--preserve-root：不对根目录进行递归操作；
-v：显示指令的详细执行过程。
===============================================================
rmdir    #注意：子目录被删除之前应该是空目录。就是说，该目录中的所有文件必须用rm命令全部，另外，当前工作目录必须在被删除目录之上，不能是被删除目录本身，也不能是被删除目录的子目录
参数：
目录列表：要删除的空目录列表。当删除多个空目录时，目录名之间使用空格隔开。
选项:
-p或--parents：删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除；
--ignore-fail-on-non-empty：此选项使rmdir命令忽略由于删除非空目录时导致的错误信息；
-v或-verboes：显示命令的详细执行过程；
--help：显示命令的帮助信息；
--version：显示命令的版本信息。
```

**3.复制目录**

```
cp -r ../ahb bbb        #把上一层的ahb目录 复制到当前bbb目录下
参数
源文件：制定源文件列表。默认情况下，cp命令不能复制目录，如果要复制目录，则必须使用-R选项；
目标文件：指定目标文件。当“源文件”为多个文件时，要求“目标文件”为指定的目录。
选项
-a：此参数的效果和同时指定"-dpR"参数相同；
-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；
-f：强行复制文件或目录，不论目标文件或目录是否已存在；
-i：覆盖既有文件之前先询问用户；
-l：对源文件建立硬连接，而非复制文件；
-p：保留源文件或目录的属性；
-R/r：递归处理，将指定目录下的所有文件与子目录一并处理；
-s：对源文件建立符号连接，而非复制文件；
-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；
-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；
-b：覆盖已存在的文件目标前将目标文件备份；
-v：详细显示命令执行的操作。
```

**4.移动目录**

```
mv -i ../ahb/* bbb        #把上级目录ahb下所有文件 移动到当前bbb目录下 (可用作重命名)
参数
源文件：源文件列表
目标文件：如果“目标文件”是文件名则在移动文件的同时，将其改名为“目标文件”；如果“目标文件”是目录名则将源文件移动到“目标文件”下
选项
--backup=<备份模式>：若需覆盖文件，则覆盖前先行备份；
-b：当文件存在时，覆盖前，为其创建一个备份；
-f：若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录；
-i：交互式操作，覆盖前先行询问用户，如果源文件与目标文件或目标目录中的文件同名，则询问用户是否覆盖目标文件。用户输入”y”，表示将覆盖目标文件；输入”n”，表示取消对源文件的移动。这样可以避免误将文件覆盖。
--strip-trailing-slashes：删除源文件中的斜杠“/”；
-S<后缀>：为备份文件指定后缀，而不使用默认的后缀；
--target-directory=<目录>：指定源文件要移动到目标目录；
-u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。
```


**5.touch命令**
touch命令有两个功能：一是用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来；二是用来创建新的空文件

```

参数：
文件：指定要设置时间属性的文件列表
选项：
-a：或--time=atime或--time=access或--time=use  只更改存取时间；
-c：或--no-create  不建立任何文件；
-d：<时间日期> 使用指定的日期时间，而非现在的时间；
-f：此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题；
-m：或--time=mtime或--time=modify  只更该变动时间；
-r：<参考文件或目录>  把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同；
-t：<日期时间>  使用指定的日期时间，而非现在的时间；
```

#### 文件权限

**1. 查看文件权限**
命令
```
ls -al
ll
```

**权限一共十位**
第一位 表示文件类型
```
“-” 代表普通文件（regular file）
“d” 代表目录（directory）
“l”代表连接文件
“b”代表块设备文件，及一些存储文件，如硬盘，软盘等，
“c”代表字符设备文件，即一些串行端口的接口文件，如键盘，鼠标等
“s”代表套接字（sockets 数据接口文件），这种类型的文件通常被用在网络上的数据连接，我们可以启动一个程序来监听客户端的请求，而客户端就可以通过数据接口文件来进行数据通信。
“p”代表管道（FIFO，pipe）
```

第2-4位
```
文件拥有者的w r x权限
```

第5-7位
```
文件所属组的w r x权限
```

第8-10位
```
其他组的w r x权限
```

**2. 修改文件权限 (root下)**

```
在linux系统中
r（读read权限），二进制是100，十进制是4
w（写write权限），二进制是010，十进制是2
x（执行excute权限），二进制是001，十进制是1
具备多个权限就要报4、2、1相加，所以最大的权限就是777
rwx  对应是二进制是111，十进制7
rw   对应的二进制是11 ，十进制6
```

```
chgrp 组名 文件名
chown 拥有者 文件名
chmod
    chmod xyz 文件或目录（xyz代表 拥有者 组 其他组的权限）
```

**3. umask命令**

```
umask命令用来设置限制新建文件权限的掩码。当新文件被创建时，其最初的权限由文件创建掩码决定。用户每次注册进入系统时，umask命令都被执行， 并自动设置掩码mode来限制新文件的权限。用户可以通过再次执行umask命令来改变默认值，新的权限将会把旧的覆盖掉。

选项
-p：输出的权限掩码可直接作为指令来执行；
-S：以符号方式输出权限掩码。
```

实例

```
umask u=, g=w, o=rwx            # 创建掩码，使得组用户的写权限，其他用户的读、写和执行权限都被取消
```

#### 查看文本命令

```shell script
cat  由第一行开始显示档案内容
tac  从最后一行开始显示，可以看出 tac 是 cat 的倒着写！
more 一页一页的显示档案内容
less 与 more 类似，但是比 more 更好的是，他可以往前翻页！
head 只看头几行
tail 只看尾巴几行
nl   显示的时候，顺道输出 行号！
od   以二进制的方式读取档案内容！
```

实例
**1. cat**

```
-b        #非空的行输出行号，空行会输出，但不标记行号
-n        #所有行都输出行号

cat file1.txt                                #屏幕上显示file1内容
cat file1.txt file2.txt                        #显示1 和2
cat file1.txt file2.txt>mfile.txt            #file1和file2的内容合并到mfile
```

**2. tac**
```shell script
tac file1.txt                                #从最后一行开始，倒序输出file1.txt的内容
```

**3. more 和 less**

more file1.txt
```
按一下空格则往下翻一页
按一下Enter则往下翻一行
按一下B键往上翻一页
不能往上一行一行的翻回去了
：f 可以显示文件名和现在的行数
q退出more
```

less file1.txt

```
more命令的所有按键less都支持
↑↓箭头可以实现一行一行的上下翻
PageDown/PageUp可以实现一页一页的上下翻
```

**4. nl**
```
b a #空行也输出行号
b t #默认设置
n ln ##行号最左方显示
n rn ##行号最右方显示，且不加0
n rz ##行号最右方显示，且加0
w ##设置行号字段占用的位数
```

**5. head 和 tail**
```
head file2.txt                          # 默认只显示文件的前10行文本内容
head -n 6 file2.txt                     # -n 6 参数指定显示文件的前6行
head -n -4 file2.txt                    #-n -4 负数表示除去文件结尾的4行，其他的从头开始的所有行都显示出来
```

```
tail file2.txt                          # 默认只显示从文件最后一行开始的10行文本内容
tail -n 5 file2.txt                     # -n 5 参数指定显示文件的最后5行
tail -n -5 file2.txt                    # **-n -5**tail命令不支持负数，执行结果同-n 5
```

**6. vim**


#### vim

**小范围移动光标**

```
h 或 向左箭头键(←)        #光标向左移动一个字符    也可30h或30←等
j 或 向下箭头键(↓)        #光标向下移动一个字符    也可30j或30↓等    同30 +        同30<enter>
k 或 向上箭头键(↑)        #光标向上移动一个字符    也可30k或30↑等    同30 -
l 或 向右箭头键(→)        #光标向右移动一个字符    也可30l或30→等    同30<space>
==========================================================================================
0 或功能键[Home]          #这是数字『 0 』：移动到这一列的最前面字符处 (常用)
$ 或功能键[End]           #移动到这一列的最后面字符处(常用)
==========================================================================================
H                        #光标移动到这个屏幕的最上方那一列的第一个字符 
M                        #光标移动到这个屏幕的中央那一列的第一个字符 
L                        #光标移动到这个屏幕的最下方那一列的第一个字符
```

**换页**

```
[Ctrl] + [f]             #屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)
[Ctrl] + [b]             #屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)
[Ctrl] + [d]             #屏幕『向下』移动半页 
[Ctrl] + [u]             #屏幕『向上』移动半页 
```

**跳页**

```
G                        #移动到这个文件的最后一列(常用)
gg                       #移动到这个文件的第一列，相当于 1G 啊！ (常用)
nG                       #n为数字。移动到这个文件的第 n 列。例如 20G 则会移动到这个文件的第 20 列(可配合 :set nu)
```

**搜素与替换**

```
/word                    #向光标之下寻找一个名称为 word 的字符串。例如要在文件内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) 
?word                    #向光标之上寻找一个字符串名称为 word 的字符串
n                        #这个 n 是英文按键。代表『重复前一个搜寻的动作』
N                        #与 n 刚好相反，为『反向』进行前一个搜寻动作

:n1,n2s/word1/word2/g    #n1 与 n2 为数字。在第 n1 与 n2 列之间寻找 word1 这个字符串，并将该字符串取代为 word2 (常用) 
:1,$s/word1/word2/g      #从第一列到最后一列寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)
:1,$s/word1/word2/gc     #从第一列到最后一列寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)
```

**删除、复制与粘贴**

```
u        #复原前一个动作。(常用)
[Ctrl]+r #重做上一个动作。(常用)   （等同于 .    #重复前一个动作）???

x        # x为向后删除一个字符 (相当于 [del] 按键)               也可用作20x
X        # X为向前删除一个字符([backspace] 亦即是退格键)         也可用作20X
dd       # 删除游标所在的那一整列(常用)                          也可用作20dd
d1G      # 删除光标所在到第一列的所有数据
dG       # 删除光标所在到最后一列的所有数据
d$       # 删除游标所在处，到该列的最后一个字符
d0       # 那个是数字的 0 ，删除游标所在处，到该列的最前面一个字符
=========================================================================================================
yy       # 复制游标所在的那一列(常用)                    也可用作20yy(常用)
y1G      # 复制光标所在列到第一列的所有数据 
yG       # 复制光标所在列到最后一列的所有数据 
y0       # 复制光标所在的那个字符到该列行首的所有数据 
y$       # 复制光标所在的那个字符到该列行尾的所有数据
=========================================================================================================
p, P     # p 为将已复制的数据在光标下一列贴上，P 则为贴在游标上一列！ 举例来说，我目前光标在第 20 列，且已经复制了 10 列数据。则按下 p 后， 那 10 列数据会贴在原本的 20 列之后，亦即由 21 列开始贴。但如果是按下 P 呢？ 那么原本的第 20 列会被推到变成 30 列。 (常用) 
=========================================================================================================
J        # 将光标所在列与下一列的数据结合成同一列        （删除回车？？？？）
c        # 重复删除多个数据，例如向下删除 10 列，[ 10cj ] 
```

#### find

语法
```shell script
find path -option [ -print ]   [ -exec -ok command ]   {} \;
```


实例
```shell script
### 使用inode删除文件
# 用stat 或者ls -il 。带有 -i 参数的ls命令，就是指显示文件的inode。
find . -inum [inode数字] -exec rm -i {} /;


# 将当前目录及其子目录下所有文件后缀为 .c 的文件列出来:
find . -name "*.c"

# 将当前目录及其子目录中的所有文件列出：
find . -type f

# 将当前目录及其子目录下所有最近 20 天内更新过的文件列出:
find . -ctime -20

# 查找 /var/log 目录中更改时间在 7 日以前的普通文件，并在删除之前询问它们：
find /var/log -type f -mtime +7 -ok rm {} \;

# 查找当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：
find . -type f -perm 644 -exec ls -l {} \;

# 查找系统中所有文件长度为 0 的普通文件，并列出它们的完整路径：
find / -type f -size 0 -exec ls -l {} \;
```

#### sort
#### comm
#### cut
#### grep
#### sed
#### awk


## shell脚本相关

#### 脚本格式

1. 以`#!/bin/bash`开头。
2. 使用sh/bash + 脚本不需要执行权限，直接使用脚本绝对路径或相对路径需要执行权限。

#### 变量类型

1. 定义变量：`变量=值` （中间不能有空格）
2. 撤销变量：unset 变量名
3. 声明静态变量：readonly变量（不能unset）

|   --  |  -- |
|  :----:  | :----  |
| global  | 作用域从定义到shell结束或者变量被删除 |
| local  | 作用域只在函数内部,函数参数是local的 |
 
#### if条件

**IF条件只能为命令（或脚本）返回值（比如./test.sh），[命令等同于test命令**

|  --   | --  |
|  ----  | ----  |
| []和test  | 在命令行里test expr和[ expr ]的效果相同(判断文件、判断字符串、判断整数) |
| 是否为文件  | if [ -f "" ] |
| 字符串长度非0  | if [ -n "" ] |
| 是否为目录  | if [ -d "" ] |
| 扩展 | https://www.cnblogs.com/pugang/p/13167714.html |
| | |
| [[ ]] | 内置在shell中的一个命令（支持字符串的模式匹配、逻辑组合可以不使用test的-a,-o而使用&& ||） |
| ~正则匹配  | if [[ $line =~ ^java\.library\.path=(.*)$ ]] |

**[] 和 [[]]的区别**
> 注意：使用[]和[[]]的时候不要吝啬空格，每一项两边都要有空格，[[ 1 == 2 ]]的结果为“假”，但[[ 1==2 ]]的结果为“真”！ 

> 1.首先，尽管很相似，但是从概念上讲，二者是不同层次的东西。"[["，是关键字，许多shell(如ash bsh)并不支持这种方式。ksh, bash(据说从2.02起引入对[[的支持)等支持。"["是一条命令， 与test等价，大多数shell都支持。在现代的大多数sh实现中，"["与"test"是内部(builtin)命令，换句话说执行"test"/"["时不会调用/some/path/to/test这样的外部命令(如果有这样的命令的话)。

> 2.[[]]结构比Bash版本的[]更通用。在[[和]]之间的所有的字符都不会被文件扩展或是标记分割，但是会有参数引用和命令替换。
用[[ ... ]]测试结构比用[ ... ]更能防止脚本里的许多逻辑错误。比如说，&&,||,<和>操作符能在一个[[]]测试里通过，但在[]结构会发生错误。

> 3.(( ))结构扩展并计算一个算术表达式的值。如果表达式值为0，会返回1或假作为退出状态码。一个非零值的表达式返回一个0或真作为退出状态码。这个结构和先前test命令及[]结构的讨论刚好相反。

> 4.[ ... ]为shell命令，所以在其中的表达式应是它的命令行参数，所以串比较操作符">" 与"<"必须转义，否则就变成IO改向操作符了(请参看上面2中的例子)。在[[中"<"与">"不需转义；
由于"[["是关键字，不会做命令行扩展，因而相对的语法就稍严格些。例如
在[ ... ]中可以用引号括起操作符，因为在做命令行扩展时会去掉这些引号，而在[[ ... ]]则不允许这样做。

> 5.[[ ... ]]进行算术扩展，而[ ... ]不做

> 6.[[ ... && ... && ... ]] 和 [ ... -a ... -a ...] 不一样，[[ ]] 是逻辑短路操作，而 [ ] 不会进行逻辑短路

#### 特殊变量

|  --   | --  |
|  ----  | ----  |
|  $'\n' | 获取换行符 |
|  $$ | Shell本身的PID（ProcessID） |
|  $! | Shell最后运行的后台Process的PID |
|  $? | 最后运行的命令的结束代码（返回值） |
|  $- | 使用Set命令设定的Flag一览 |
|  $* | 所有参数列表。如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数 |
|  $@ | 所有参数列表。如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数 |
|  $# | 添加到Shell的参数个数 |
|  $0 | Shell本身的文件名 |
|  $1～$n | 添加到Shell的各参数值。$1是第1参数、$2是第2参数… |
|  shift | 位置参数可以用shift命令左移。比如shift 3表示原来的$4现在变成$1，原来的$5现在变成$2等等，原来的$1、$2、$3丢弃，$0不移动。不带参数的shift命令相当于shift 1。 |

#### 流程控制（待补充）