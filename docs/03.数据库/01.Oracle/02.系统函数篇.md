---
title: 系统函数篇
date: 2022-03-02 17:21:38
permalink: /pages/b5c27a/
---

## Oracle

---
### L[R]PAD

```text
语法
LPAD(string,padded_length,[ pad_string]) :从左开始填充,L:left 左,PAD:pad 填充
RPAD(string,padded_length,[ pad_string]) :从右开始填充,R:right 右,PAD:pad 填充

解释
string：原数据，即要被填充的数据；
padded_length：填充后的长度；
pad_string：填充字符串 可选填，如果不填就粘贴空格
```

### lag/lead

```text
lead(value_expr [,offset][,default]) over([query_partition_clause] order by Order_by_clause)

lag(exp_str,offset,defval) over()
exp_str 是要做对比的字段
offset 是exp_str字段的偏移量 比如说 offset 为2 则 拿exp_str的第一行和第三行对比，第二行和第四行，依次类推，offset的默认值为1！
defval是当该函数无值可用的情况下返回的值。Lead函数的用法类似。
```

### wm_concat


### SYS.UTL_MATCH.edit_distance_similarity 文本相似度计算

```sql
       SELECT  A.AGENCY_ID,A.AGENCY_CODE,A.AGENCY_NAME,A.MOF_DIV_CODE,A.MOF_DIV_NAME,B.GUID,B.NAME,B.CODE,PROVINCE 
         FROM  YTHDWXX A
         JOIN  DZXTDWXX B
           ON  SYS.UTL_MATCH.edit_distance_similarity(a.agency_name,b.name) = 80
          AND  MOF_DIV_CODE = rpad(PROVINCE, 9, 0)
```


### oracle根据分隔符将一行拆分为多行

```sql
--oracle根据分隔符将一行拆分为多行
with tmp as --临时数据集
(select '1,2,3' val
    from dual
  union all
  select '4,5,6' val
    from dual)
select regexp_substr(t.val, '[^,]+', 1, t2.lv)--截取对应行数的数据
  from tmp t,
      (select level lv--生成行数序列数据 1到最大行数
          from (select max(regexp_count(a.val, '[^,]+', 1)) r_count--计算数据集中拆分后最大的行数
                  from tmp a) b
        connect by level <= b.r_count) t2
where regexp_substr(t.val, '[^,]+', 1, t2.lv) is not null-- 排除掉空的数据
```