---
title: 系统函数篇
date: 2022-03-02 17:21:38
permalink: /pages/b5c27a/
---

## Oracle

---
### 聚合函数lag/lead

```text
lead(value_expr [,offset][,default]) over([query_partition_clause] order by Order_by_clause)

lag(exp_str,offset,defval) over()
exp_str 是要做对比的字段
offset 是exp_str字段的偏移量 比如说 offset 为2 则 拿exp_str的第一行和第三行对比，第二行和第四行，依次类推，offset的默认值为1！
defval是当该函数无值可用的情况下返回的值。Lead函数的用法类似。
```

### 聚合函数wm_concat

多行变一行

### 单行函数L[R]PAD

```text
语法
LPAD(string,padded_length,[ pad_string]) :从左开始填充,L:left 左,PAD:pad 填充
RPAD(string,padded_length,[ pad_string]) :从右开始填充,R:right 右,PAD:pad 填充

解释
string：原数据，即要被填充的数据；
padded_length：填充后的长度；
pad_string：填充字符串 可选填，如果不填就粘贴空格
```

### 单行函数MD5加密

```sql
select utl_raw.cast_to_raw(DBMS_OBFUSCATION_TOOLKIT.MD5(INPUT_STRING => 'test')) from dual
```

### SYS.UTL_MATCH.edit_distance_similarity 文本相似度计算

::: details
过程梳理：

    由于有两个数据量过万的表数据进行对比，且编码不一致不能进行比对，只能通过同一区划，相似名称进行比对，确认一对一关系。
    
    确定思路是把数据分成多部分，能确认一对一关系的先插入结果表中。
    
    先能想到的是通过等值关联取能关联上的先插入到结果表。
    
    后通过instr(str1, str2) > 0关联，将此部分数据插入到结果表。
    
    后由于instr只能找出连续子串，非连续的简称一类并不能解决，采用自定义函数通过遍历短字符串的每个字符，到长字符串中查找如果有找不到的字符，返回-1；若全能找到返回短串的长度。
    
    后由于有些名称有错别字或其他问题，上面的自定义函数并不能解决，故考虑判断字符串的相似度，Oracle自带判断文本相似度函数，故用其作为关联条件。
:::

```sql
SELECT  A.AGENCY_ID,A.AGENCY_CODE,A.AGENCY_NAME,A.MOF_DIV_CODE,A.MOF_DIV_NAME,B.GUID,B.NAME,B.CODE,PROVINCE 
 FROM  YTHDWXX A
 JOIN  DZXTDWXX B
   ON  SYS.UTL_MATCH.edit_distance_similarity(a.agency_name,b.name) > 80
  AND  MOF_DIV_CODE = rpad(PROVINCE, 9, 0)
```

### oracle根据分隔符将一行拆分为多行

```sql
--oracle根据分隔符将一行拆分为多行
with tmp as --临时数据集
(select '1,2,3' val
    from dual
  union all
  select '4,5,6' val
    from dual)
select regexp_substr(t.val, '[^,]+', 1, t2.lv)--截取对应行数的数据
  from tmp t,
      (select level lv--生成行数序列数据 1到最大行数
          from (select max(regexp_count(a.val, '[^,]+', 1)) r_count--计算数据集中拆分后最大的行数
                  from tmp a) b
        connect by level <= b.r_count) t2
where regexp_substr(t.val, '[^,]+', 1, t2.lv) is not null-- 排除掉空的数据
```

### 自定义函数(存储过程)

**用于匹配简称**

```sql
-- 一个字符串包含另一个字符串中的所有字符
create or replace function checks(v_a varchar2,v_b varchar)
return number
as
  num number;
  cou number;
  j number;
  index1 number;
begin
  num := -1;
  cou:=0;
  j := 0;
  index1 := 1;
  for i in 1..length(v_b) loop
     j := instr( substr(v_a,index1,length(v_a)), substr(v_b,i,1) );
     if j > 0 then
      cou:=cou+1;
      index1 := index1 + j;
     else
      return num;
     end if;
  end loop;
  return cou;
  --dbms_output.put_line(cou||'    '||length(v_b));
end;
```

