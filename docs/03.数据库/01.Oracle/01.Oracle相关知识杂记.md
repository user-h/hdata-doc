---
title: Oracle相关知识杂记
date: 2022-02-23 12:58:51
permalink: /pages/7e6951/
categories: 
  - 数据库
  - Oracle
tags: 
  - 
---


## 查看表空间大小

---
```sql
--oracle表空间大小
SELECT a.tablespace_name "表空间名",
       total "表空间大小",
       free "表空间剩余大小",
       (total - free) "表空间使用大小",
       round(total / (1024 * 1024 * 1024),2) "表空间大小(G)",
       round(free / (1024 * 1024 * 1024),2) "表空间剩余大小(G)",
       round((total - free) / (1024 * 1024 * 1024),2) "表空间使用大小(G)",
       round((total - free) / total, 4) * 100 "使用率 %"
  FROM (SELECT tablespace_name, SUM(bytes) free
          FROM dba_free_space
         GROUP BY tablespace_name) a,
       (SELECT tablespace_name, SUM(bytes) total
          FROM dba_data_files
         GROUP BY tablespace_name) b
 WHERE a.tablespace_name = b.tablespace_name
```

**查看单表占用磁盘空间**

```sql
SELECT *
  FROM (SELECT T.TABLESPACE_NAME,
               T.OWNER,
               T.SEGMENT_NAME,
               T.SEGMENT_TYPE,
               SUM(T.BYTES / 1024 / 1024) MB
          FROM DBA_SEGMENTS T
         WHERE T.SEGMENT_TYPE = 'TABLE' AND T.SEGMENT_NAME = 'TABLE_NAME'
         GROUP BY T.TABLESPACE_NAME, T.OWNER, T.SEGMENT_NAME, T.SEGMENT_TYPE) T
 ORDER BY T.MB DESC;
```

## 查看锁表及解决

---
```sql
1.下面的语句用来查询哪些对象被锁：
select object_name,machine,s.sid,s.serial#,l.ORACLE_USERNAME
from v$locked_object l,dba_objects o ,v$session s
where l.object_id　=　o.object_id and l.session_id=s.sid;
2.下面的语句用来杀死一个进程：
alter system kill session '24,111'; (其中24,111分别是上面查询出的sid,serial#);
3.批量删除
select 'alter system kill session ''' || s.sid || ',' || s.serial# || '''' || ';'
  from v$locked_object l, dba_objects o, v$session s
 where l.object_id　 = 　o.object_id
   and l.session_id = s.sid;

select object_name,a.SQL_TEXT,machine,s.sid,s.serial#,s.status,lockwait,machine,program
from v$locked_object l,dba_objects o ,v$session s,v$sql a
where l.object_id　=　o.object_id and l.session_id=s.sid and a.HASH_VALUE = s.SQL_HASH_VALUE;
Username：死锁语句所用的数据库用户；
Lockwait：死锁的状态，如果有内容表示被死锁。
Status： 状态，active表示被死锁
Machine： 死锁语句所在的机器。
Program： 产生死锁的语句主要来自哪个应用程序。



select b.file_id　　文件ID,
　　b.tablespace_name　　表空间,
　　b.file_name　　　　　物理文件名,
　　b.bytes　　　　　　　总字节数,
　　(b.bytes-sum(nvl(a.bytes,0)))　　　已使用,
　　sum(nvl(a.bytes,0))　　　　　　　　剩余,
　　sum(nvl(a.bytes,0))/(b.bytes)*100　剩余百分比
　　from dba_free_space a,dba_data_files b
　　where a.file_id=b.file_id
　　group by b.tablespace_name,b.file_name,b.file_id,b.bytes
　　order by b.tablespace_name



--最新
select object_name,a.SQL_TEXT,machine,s.sid,s.serial#,s.status,lockwait,machine,program,l.ORACLE_USERNAME
from v$locked_object l,dba_objects o ,v$session s,v$sql a
where l.object_id　=　o.object_id and l.session_id=s.sid and a.HASH_VALUE = s.SQL_HASH_VALUE;

alter system kill session '1902,24317'; 


grant alter system to ysgl_guanli
```

## 刷新表统计信息（做表分析）

&emsp;&emsp;统计信息主要是描述数据库中表，索引的大小，规模，数据分布状况等的一类信息。例如，表的行数，块数，平均每行的大小，索引的leaf blocks，索引字段的行数，不同值的大小等，都属于统计信息。CBO正是根据这些统计信息数据，计算出不同访问路径下，不同join 方式下，各种计划的成本，最后选择出成本最小的计划。

&emsp;&emsp;统计信息是存放在数据字典表中的，如tab$，一般可通过察看某些视图来获取统计信息状况，如DBA_TABLES,DBA_INDEXES,DBA_TAB_COL_STATISTICS, DBA_TAB_HISTOGRAMS等。在这些视图中包含表示统计信息的一些字段，这些字段只有搜集过统计信息之后才有值，否则是空的。例如，last_analyzed 字段表示上次统计信息搜集的时间，可以根据这个字段，快速的了解最近一次统计信息搜集的时间。

**博客：** [有关Oracle统计信息的知识点](https://www.cnblogs.com/youngerger/p/9050679.html)
**博客：** [Oracle 11g新特性之统计信息收集](https://www.xp.cn/b.php/7376.html)

```sql
--当表没有做分析的时候，Oracle 会使用动态采样来收集统计信息。获取准确的段对象（表，表分区，索引等）的分析数据，是CBO存在的基石，
--CBO的机制就是收集尽可能多的对象信息和系统信息，通过对这些信息进行计算，分析，评估，最终得出一个成本最低的执行计划。
--所以对于CBO，数据段的分析就非常重要。

解锁单个用户schema
exec dbms_stats.unlock_schema_stats('用户名');

单个表统计数据的统计数据更新
EXEC dbms_stats.gather_table_stats('【username】','【tablename】', estimate_percent => dbms_stats.auto_sample_size, cascade=>true);
-- EXEC dbms_stats.gather_table_stats('【username】','【tablename】',cascade=>true);
-- analyze table tablename compute statistics 等同于 analyze table tablename compute statistics for table for all indexes for all columns

-- 更新整个用户所有表的统计数据更新
-- EXEC dbms_stats.gather_schema_stats('【username】',estimate_percent=>100,cascade=> TRUE);


参数说明: (https://www.cnblogs.com/tingxin/p/12663682.html)
ownname:要分析表的拥有者
tabname:要分析的表名.
partname:分区的名字,只对分区表或分区索引有用.
estimate_percent:采样行的百分比,取值范围[0.000001,100],null为全部分析,不采样. 常量:DBMS_STATS.AUTO_SAMPLE_SIZE是默认值,由oracle决定最佳取采样值.
block_sapmple:是否用块采样代替行采样.
method_opt:决定histograms信息是怎样被统计的.method_opt的取值如下(默认值为FOR ALL COLUMNS SIZE AUTO):
for all columns:统计所有列的histograms.
for all indexed columns:统计所有indexed列的histograms.
for all hidden columns:统计你看不到列的histograms
for columns <list> SIZE <N> | REPEAT | AUTO | SKEWONLY:统计指定列的histograms.N的取值范围[1,254]; REPEAT上次统计过的histograms;AUTO由oracle决定N的大小;SKEWONLY multiple end-points with the same value which is what we define by "there is skew in thedata
degree:决定并行度.默认值为null.
granularity:Granularity of statistics to collect ,only pertinent if the table is partitioned.
cascade:是收集索引的信息.默认为FALSE.
stattab:指定要存储统计信息的表,statid如果多个表的统计信息存储在同一个stattab中用于进行区分.statown存储统计信息表的拥有者.以上三个参数若不指定,统计信息会直接更新到数据字典.
no_invalidate: Does not invalidate the dependent cursors if set to TRUE. The procedure invalidates the dependent cursors immediately if set to FALSE.
force:即使表锁住了也收集统计信息.


这是对命令与工具包的一些总结
1、对于分区表，建议使用DBMS_STATS，而不是使用Analyze语句。
a) 可以并行进行，对多个用户，多个Table
b) 可以得到整个分区表的数据和单个分区的数据。
c) 可以在不同级别上Compute Statistics：单个分区，子分区，全表，所有分区
d) 可以倒出统计信息
e) 可以用户自动收集统计信息
2、DBMS_STATS的缺点
a) 不能Validate Structure
b) 不能收集CHAINED ROWS, 不能收集CLUSTER TABLE的信息，这两个仍旧需要使用Analyze语句。
c) DBMS_STATS 默认不对索引进行Analyze，因为默认Cascade是False，需要手工指定为True
3、对于oracle 9里面的External Table，Analyze不能使用，只能使用DBMS_STATS来收集信息。

```

## SCN

---
```sql
SCN（System Change Number），也就是通常所说的系统改变号，是数据库中非常重要的一个数据结构。
SCN用以标识数据库在某个确切时刻提交的版本。在事务提交时，它被赋予一个唯一的标识事务的SCN。SCN同时被作为Oracle数据库的内部时钟机制，可被看做逻辑时钟，每个数据库都有一个全局的SCN生成器。
作为数据库内部的逻辑时钟，数据库事务依SCN而排序，Oracle也依据SCN来实现一致性读（Read Consistency）等重要数据库功能。另外对于分布式事务（Distributed Transactions），SCN也极为重要，这里不做更多介绍。
SCN在数据库中是唯一的，并随时间而增加，但是可能并不连贯。除非重建数据库，SCN的值永远不会被重置为0.
一直以来，对于SCN有很多争议，很多人认为SCN是指System Commit Number，而通常SCN在提交时才变化，所以很多时候，这两个名词经常在文档中反复出现。即使在Oracle的官方文档中，SCN也常以System Change/Commit Number两种形式出现。
到底是哪个词其实不是很重要，重要的是需要知道SCN是Oracle内部的时钟机制，Oracle通过SCN来维护数据库的一致性，并通过SCN实施Oracle至关重要的恢复机制。
SCN在数据库中是无处不在，常见的事务表、控制文件、数据文件头、日志文件、数据块头等都记录有SCN值。
冠以不同前缀，SCN也有了不同的名称，如检查点SCN（Checkpint SCN）、Resetlogs SCN等。

-- 当前scn号和时间的对应关系：
select dbms_flashback.get_system_change_number,SCN_TO_TIMESTAMP(dbms_flashback.get_system_change_number) from dual;

-- 查询当前scn：
select CURRENT_SCN from v$database;
select dbms_flashback.get_system_change_number from dual;

-- SCN与时间的相互转换
将SCN转换成时间戳: SCN_TO_TIMESTAMP(scn_number)
将时间戳转换成SCN: TIMESTAMP_TO_SCN(timestamp)

了解更多请核查看博客：https://blog.csdn.net/fuwencaho/article/details/21256973

```

## LogMiner

---
众所周知，所有对用户数据和数据字典的改变都记录在Oracle的Redo Log中，因此，Redo Log包含了所有进行恢复操作所需要的信息。但是，原始的Redo Log文件无法看懂，所以，Oracle从8i以后提供了一个非常有用的分析工具，称为LogMiner。使用该工具可以轻松获得Redo Log文件（包含归档日志文件）中的具体内容。特别是该工具可以分析出所有对于数据库的DML操作（INSERT、UPDATE、DELETE等）语句。Oracle 9i后可以分析DDL语句，另外还可分析得到一些必要的回滚SQL语句。LogMiner一个最重要的用途就是不用全部恢复数据库就可以恢复数据库的某个变化。该工具特别适用于调试、审计或者回退某个特定的事务。
LogMiner工具既可以用来分析在线日志，也可以用来分析离线日志文件，既可以分析本身自己数据库的重作日志文件，也可以用来分析其它数据库的重作日志文件。当分析其它数据库的重作日志文件时，需要注意的是，LogMiner必须使用被分析数据库实例产生的字典文件，而不是安装LogMiner的数据库产生的字典文件，另外，必须保证安装LogMiner数据库的字符集和被分析数据库的字符集相同。源数据库（Source Database）平台必须和分析数据库（Mining Database）平台一样。
Oracle通过LogMiner工具对Redo Log进行挖掘，显示出一系列可读的信息，该过程称为日志挖掘。LogMiner通过V$LOGMNR_CONTENTS视图显示Redo Log中的信息。

总的说来，LogMiner工具的主要用途有：
1. 跟踪数据库的变化：可以离线地跟踪数据库的变化，而不会影响在线系统的性能
2. 回退数据库的变化：回退特定的变化数据，减少Point-In-Time Recovery的执行
3. 优化和扩容计划：可通过分析日志文件中的数据以分析数据的增长模式
4. 确定数据库的逻辑损坏时间：准确定位操作执行的时间和SCN
5. 确定事务级要执行的精细逻辑恢复操作，可以取得相应的UNDO操作
6. 执行后续审计

了解更多请查看博客： https://blog.csdn.net/yes_is_ok/article/details/79296614

## 动态性能视图(x$,v$,gv$,v_$,gv_$)

---
| 名称 | 含义 |
|:----|:----|
| V$ACCESS | 显示当前被锁定的数据库中的对象及正在访问它们的会话。 |
| V$ACTIVE_INSTANCES | 为当前安装的数据库中出现的所有实例建立从实例名到实例号码的映射。 |
| V$AQ | 描述当前数据库中队列的统计量。 |
| V$ARCHIVE | 包含归档所需的重做日志文件中的信息。每一行提供了一个线程所需的信息。V$ARCHIVE这些信息在V$LOG中也是可用的。Oracle建议你使用V$LOG. |
| V$ARCHIVE_DEST | 描述当前实例的所有归档日志目的文件及它们的当前值、模式和状态。 |
| V$ARCHIVED_LOG | 显示控制文件中的归档日志信息，包括归档日志名。在联重做日志文件成功地归档或清除（如果日志被清除，名字列将为NULL）后，一条归档日志记录被插入。如果这个日志被归档两次，那么就将有两条具有相同THREAD#，SEQUENCE#，FIRST_CHANG#值的归档日志记录，但它们的名字不同。当一个归档日志从一个备份集或一个副本中被恢复时，一个归档日志记录也将被插入。 |
| V$ARCHIVE_PROCESSES | 为一个实例提供关于不同ARCH进程状态的信息。 |
| V$BACKUP | 显示所有联机数据文件的备份状态。 |
| V$BACKUP_ASYNC_IO | 从控制文件中显示备份集的信息。在这个备份集成功完成后，一个备份集记录将被插入。 |
| V$BACKUP_CORRUPTION | 从控制文件中显示数据文件备份中有关损坏的信息。注意在控制文件和归档日志备份文件中损坏是不能容忍的。 |
| V$BACKUP_DATAFILE | 从控制文件中显示备份数据文件和备份控制文件的信息。 |
| V$BACKUP_DEVICE | 显示关于支持备份设备的信息。如果一个设备类型不支持指名的设备，那么将为这个设备类型返回一个带有设备类型和NULL设备名的行。如果一个设备类型支持指名的设备，那么将为每一个这种类型的可用设备返回一行。特殊的设备类型DISK不会通过这个视图返回，因为它总是可用的 |
| V$BACKUP_PIECE | 从控制文件中显示备份块的信息。每一个备份集由一个更多个备份块组成。 |
| V$BACKUP_REDOLOG | 从控制文件中显示关于备份集中归档日志的信息。注意联机的重做日志文件不能够被直接备份。它们必须首先被存储到磁盘上然后再进行备份。一个归档日志备份集能包含一个或多个归档日志。 |
| V$BACKUP_SET | 从控制文件中显示备份集的信息。在备份集成功完成后，一个备份集记录将被插入。V$BACKUP_SYNC_IO从控制文件中显示备份集的信息。在备份集成功完成后，一个备份集记录将被插入。 |
| V$BGPROCESS | 描述后台进程。 |
| V$BH | 这是一个并行服务器视图。这个视图为系统全局区中的每一个缓冲区给出了状态和探查次数。 |
| V$BUFFER_POOL | 显示关于这个实例所有可用缓冲池的信息。这个“集合数”属于LRU简易锁集的数目。 |
| V$BUFFER_POOL_STATISTICS | 显示关于这个实例所有可用缓冲池的信息。这个“集合数”属于LRU简易锁集的数目。 |
| V$CACHE | 这是一个并行服务器视图。这个视图包含当前实例的SGA中的每一个块的头部信息，这个实例是与一个特殊数据库对象相关联的。 |
| V$CACHE_LOCK | 这是一个并行服务器的视图。除了特殊平台锁管理器标识符不同外，V$CACHE_LOCK与V$CACHE非常相似。如果这个特殊平台锁管理器为监视当前正发生的PCM锁操作提供了工具，那么这些信息可能是有用的。 |
| V$CIRCUIT | 包含关于虚电路的信息，这个虚电路是用户通过调度程序和服务器到数据库的所有连接。 |
| V$CLASS_PING | 显示每一个块类中被探查块的数目。用这个视图可以比较不同类的块竞争。 |
| V$COMPATIBILITY | 显示数据库实例使用中的特征，可能阻止系统性能下降到先前的版本。这是这些信息的动态（SGA）版本，它不可能反映出所用过的另外一些实例的特征，并可能包含暂时的不兼容性（如UNDO段），不过这将在数据库完全的关闭掉后不复存在。 |
| V$COMPATSEG | 列出数据库使用中的永久性的特征，这些特征将会阻止数据库回到早期的版本中去。 |
| V$CONTEXT | 列出当前对话的设置属性。 |
| V$CONTROLFILE | 列出控制文件的名字。 |
| V$CONTROLFILE_RECORD_SECTION | 显示关于控制文件记录部分的信息。 |
| V$COPY_CORRUPTION | 显示关于控制文件中数据文件副本损坏的信息。 |
| V$DATABASE | 包含控制文件中数据库信息。 |
| V$DATAFILE | 包含控制文件中数据库文件的信息。 |
| V$DATAFILE_COPY | 显示控制文件中数据文件副本的信息。 |
| V$DATAFILE_HEADER | 显示数据文件头部的数据文件信息。 |
| V$DBFILE | 列出组成数据库中的所有数据文件。这个视图是为历史兼容性保留的，我们建议用V$DATAFILE来代替。 |
| V$DBLINK | 描述由发布对V$DBLINK查询的会话所打开的所有数据库链接（用IN_TRANSACTION=YES链接）。这些数据库链接必须在关闭前被提交或滚回。 |
| V$DB_OBJECT_CACHE | 显示缓存在库高速缓存中的数据库对象。这些对象包括表、索引、簇、同义词定义、PL/SQL过程和包及触发器。 |
| V$DB_PIPES | 显示当前数据库中的管道。 |
| V$DELETED_OBJECT | 显示控制文件中被删除归档日志、数据文件副本和备份块的信息。这个视图的唯一目的是优化恢复目录的再同步操作。当一个归档日志、数据文件副本或备份块被删除时，相应的记录将被做上删除标志。 |
| V$DISPATCHER | 提供调度进程的信息。 |
| V$DISPATCHER_RATE | 为调度进程提供速率统计量。 |
| V$DLM_ALL_LOCKS | 这是一个并行服务器视图。V$DLM_ALL_LOCKS列出当前所有锁的信息，这些是锁管理器已知的被阻塞或阻塞其他对象的锁信息。 |
| V$DLM_CONVERT_LOCAL | 显示本地锁转换操作所消耗的时间。 |
| V$DLM_CONVERT_REMOTE | 显示远程锁转换操作所消耗的时间。 |
| V$DLM_LOCKS | 这是一个并行服务器视图。V$DLM_ALL_LOCKS列出当前所有锁的信息，这些是锁管理器已知的被阻塞或阻塞其他对象的锁信息。 |
| V$DLM_MISC | 显示多种DLM统计量。 |
| V$DLM_RESS | 这是一个并行服务器的视图，它显示了当前锁管理器已知的全部资源的信息。 |
| V$ENABLEDPRIVS | 显示被授予的权限。这些权限可以在SYS.SYSTEM_PRIVILEGES_MAP这个表中找到。 |
| V$ENQUEUE_LOCK | 显示排队状态对象所拥有的全部锁。这个视图中的列等同于V$LOCK中的列。更多的信息参见V$LOCK. |
| V$EVENT_NAME | 包含等待事件的信息。 |
| V$EXECUTION | 显示并行执行中的信息。 |
| V$FALSE_PING | 这是一个并行服务器视图。这个视图显示可能得到探查失败的缓冲区，探查被同样锁保护的缓冲区10次以上，如像另一个探查10次以上的缓冲区。被鉴别为获得探查失败信息的缓冲区能够被重新映射到GC_FILES_TO_LOCKS中以减少锁的冲突。 |
| V$FAST_START_SERVERS | 提供关于执行并行事务恢复的所有从属恢复操作的信息。 |
| V$FAST_START_TRANSACTIONS | 包含关于Oracle恢复中的事务进展信息。 |
| V$FILE_PING | 显示每一个数据文件被探查的块数目。反过来，这些信息能被用来决定对一个存在的数据文件访问方式，同时也可以决定从数据文件块到PCM锁的新的映射。 |
| V$FILESTAT | 包含文件关于读/写统计量的信息 |
| V$FIXED_TABLE | 显示数据库中所有动态性能表、视图和导出表。一些V$表（如V$ROLLNAME）涉及到了真正的表，没有被列出来。 |
| V$FIXED_VIEW_DEFINITION | 包含所有固定视图的定义（以V$开头的视图）。应谨慎地使用这个表。Oracle总是想从版本到版本保持固定视图的行为，但是固定视图的定义能够在没有通知的情况下改变。用这些定义通过使用动态性能表中的索引列可以优化你的查询。 |
| V$GLOBAL_BLOCKED_LOCKS | 显示全局块锁。 |
| V$GLOBAL_TRANSACTION | 显示当前激活的全局事务的信息。 |
| V$HS_AGENT | 标识当前运行在一个给定的主机上的HS代理的集合，每一个代理进程用一行表示。 |
| V$HS_SESSION | 标识当前为一个Oracle服务器打开的HS会话集。 |
| V$INDEXED_FIXED_COLUMN | 显示建立索引的动态性能表中的列（X$表），X$表能够在没有通知的情况下改变。使用这个视图仅仅在写查询方面比固定视图（V$视图）的效率要高。 |
| V$INSTANCE | 显示当前实例的状态。这个V$INSTANCE版本同早期的V$INSTANCE版本不兼容。 |
| V$INSTANCE_RECOVERY | 用来监视执行用户指定恢复读次数的限制机制。 |
| V$LATCH | 为非双亲简易锁列出统计表，同时为双亲简易锁列出总计统计。就是说，每一个双亲简易锁的统计量包括它的每一个子简易锁的计算值。 |
| V$LATCHHOLDER | 包含当前简易锁持有者的信息。 |
| V$LATCHNAME | 包含关于显示在V$LATCH中的简易锁的解码简易锁名字的信息。中的行与V$LATCH中的行有一一对应的关系。 |
| V$LATCH_CHILDREN | 包含关于子简易锁的统计量。这个视图包括V$LATCH中的所有列和一个CHILD#列。注意如果子简易锁LATCH#列相匹配，那么它们将具有相同的双亲。 |
| V$LATCH_MISSES | 包含试图获得一个简易锁失败的统计量。 |
| V$LATCH_PARENT | 包含关于双亲简易锁的统计量。V$LATCH_PARENT中的列与V$LATCH中的列是相等的。 |
| V$LIBRARYCACHE | 包含关于高速缓存性能和活动的统计量。 |
| V$LICENSE | 包含关于许可证限制的信息。 |
| V$LOADCSTAT | 包含在一个直接装载执行过程中所编译的SQL*Loader统计量。这些统计量适用于整个的加载。既然装载数据和查询不能在同一时间进行，那么，任何对这个表的SELECT操作都将会导致”no rows retured”(没有行返回)。 |
| V$LOCK | 列出当前ORACLE服务器所持有的锁和对一个锁或简易锁的未决请求。 |
| V$LOCK_ACTIVITY | 这是一个并行服务器视图。它显示当前实例的DLM锁操作活动，每一行对应着锁操作的类型。 |
| V$LOCK_ELEMENT | 这是一个并行服务器视图。每一个被缓冲高速缓存使用的PCM锁在V$LOCK_ELEMENT中都有一个条目。与一个锁元素相对应的PCM锁的名字是（‘BL’，indx,class）。 |
| V$LOCKED_OBJECT | 列出在这个系统中每一个事务所获得的全部锁。 |
| V$LOCKS_WITH_COLLISIONS | 这是一个并行服务器视图。用这个视图可以查找保护多重锁缓冲区的锁，这些缓冲区的每一个至少被强制性的读或写达十次以上。那些正经历着探查失败的缓冲区，主要是由于被映射到同样的锁上。 |
| V$LOG | 包含控制文件中的日志文件信息。 |
| V$LOGFILE | 包含重做日志文件的信息。 |
| V$LOGHIST | 包含控制文件中的日志历史信息。这个视图是为历史兼容性保留的。这里建议使用V$LOG_HISTORY来代替它。 |
| V$LOGMNR_CONTENTS | 包含日志历史信息。 |
| V$LOGMNR_DICTIONARY | 包含日志历史信息。 |
| V$LOGMNR_LOGS | 包含日志信息。 |
| V$LOGMNR_PARAMETERS | 包含日志信息。 |
| V$LOG_HISTORY | 包含控制文件中的日志历史信息。 |
| V$MLS_PARAMETERS | 这是一个ORACLE委托服务器（Trusted Oracle Server）视图，这个视图列出ORACLE指定委托服务器的初始化参数。更多的信息，可以在你的ORACLE委托文件中查到。 |
| V$MTS | 包含调节多线程的服务器的信息。 |
| V$MYSTAT | 包含当前会话的统计量。 |
| V$NLS_PARAMETERS | 包含当前NLS参数的值。 |
| V$NLS_VALID_VALUES | 列出NLS参数所有有效的信息。 |
| V$OBJECT_DEPENDENCY | 能够通过当前装戴在共享池中的包、过程或游标来决定依赖于那一个对象。例如，与V$SESSIONV和$SQL一起，它能被用来决定在SQL语句中使用哪一个正在被用户执行的表。要知道更多的信息，请见V$SESSION和V$SQL |
| V$OBSOLETE_PARAMETER | 列出陈旧的参数。只要有某一值为TRUE，你就应该检查为什么。 |
| V$OFFLINE_CURSOR | 显示控制文件中数据文件的脱机信息。 |
| V$OPEN_CURSOR | 列出每一个用户会话当前打开的和解析的游标。 |
| V$OPTION | 列出用ORACLE服务器安装的选项。 |
| V$PARALLEL_DEGREE_LIMIT_MTH | 显示所有有效的并行度限制资源分配的方法。 |
| V$PARAMETER | 列出关于初始化参数的信息。 |
| V$PING | 这是一个并行服务器视图。除了只显示至少被探查一次的块有所不同外，V$PING视图与V$CACHE视图完全是一样的，这个视图包含当前实例的SGA中每一块的块首部信息，这个实例是与一个特定的数据库对象相关联的。 |
| V$PQ_SESSTAT | 列出并行查询会话的统计信息。注意：这个视图在未来的版本中将会成为过的 |
| V$PQ_SLAVE | 列出一个实例上每个活动并行执行服务器的统计量。注意：这个视图在未来的版本中将会过时而被一个新的称做V$PX_PROCESS的视图所代替。 |
| V$PQ_SYSSTAT | 列出并行查询的系统统计量。注意：这个视图在未来的版本中将会过时而被一个新的称做V$PX_PROCESS_SYSSTAT的视图所代替。 |
| V$PQ_TQSTAT | 包含并行执行操作上的统计量。这些统计量是在完成了查询后编辑的，并且仅在会话期保持。它显示在执行树的每一级阶段，通过每一个并行运行服务器处理的行数。这个视图能够帮助在一个查询执行中测定不平衡的问题。注意：这个视图在未来的版本中将称做V$PX_TQSTAT视图。 |
| V$PROCESS | 包含关于当前活动进程的信息。当LATCHWAIT列显示一个进程正等待什么样的简易锁时，LATCHSPIN列就显示一个进程正围绕什么样简易锁运行。在多处理器机器上，ORACLE进程在等待一个简易锁之前是围绕它运行的。 |
| V$PROXY_ARCHIVEDLOG | 包含归档日志备份文件的描述信息，这些备份文件带有一个称为Proxy副本的新特征。每一个行代表一个归档日志的备份信息。 |
| V$PROXY_DATAFILE | 包含数据文件和控制文件备份的描述信息，这个备份文件带了一个称为Proxy副本的新特征。每一行代表一个数据库文件的备份信息。 |
| V$PWFILE_USERS | 列出被授予SYSDBA和SYSOPER权限的用户，这些权限就象从password文件中衍生而来一样。 |
| V$PX_PROCESS | 包含正运行并行操作的会话的信息。 |
| V$PX_PROCESS_SYSSTAT | 包含正运行并行操作的会话的信息。 |
| V$PX_SESSION | 包含正运行并行操作的会话的信息。 |

```sql
原文链接：https://blog.csdn.net/junmail/article/details/2671165

v$database 数据库信息
v$datafile 数据文件信息
v$controlfile 控制文件信息
v$logfile 重做日志信息
v$instance 数据库实例信息
v$log 日志组信息
v$loghist 日志历史信息
v$sga 数据库SGA信息
v$parameter 初始化参数信息
v$process 数据库服务器进程信息
v$bgprocess 数据库后台进程信息
v$controlfile_record_section 控制文件记载的各部分信息
v$thread 线程信息
v$datafile_header 数据文件头所记载的信息
v$archived_log归档日志信息
v$archive_dest 归档日志的设置信息
v$logmnr_contents 归档日志分析的DML DDL结果信息
v$logmnr_dictionary 日志分析的字典文件信息
v$logmnr_logs 日志分析的日志列表信息
v$tablespace 表空间信息
v$tempfile 临时文件信息
v$filestat 数据文件的I/O统计信息
v$undostat Undo数据信息
v$rollname 在线回滚段信息
v$session 会话信息
v$transaction 事务信息
v$rollstat 回滚段统计信息
v$pwfile_users 特权用户信息
v$sqlarea 当前查询过的sql语句访问过的资源及相关的信息
v$sql 与v$sqlarea基本相同的相关信息
v$sysstat 数据库系统状态信息
```

## 常用系统表

[原文链接](https://blog.csdn.net/qq814965130/article/details/79305220?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5.pc_relevant_default&utm_relevant_index=10)

**dba_开头**
```text

dba_users 数据库用户信息
dba_segments 表段信息
dba_extents 数据区信息
dba_objects 数据库对象信息
dba_tablespaces 数据库表空间信息
dba_data_files 数据文件设置信息
dba_temp_files 临时数据文件信息
dba_rollback_segs 回滚段信息
dba_ts_quotas 用户表空间配额信息
dba_free_space 数据库空闲空间信息
dba_profiles 数据库用户资源限制信息
dba_sys_privs 用户的系统权限信息
dba_tab_privs 用户具有的对象权限信息
dba_col_privs 用户具有的列对象权限信息
dba_role_privs 用户具有的角色信息
dba_audit_trail 审计跟踪记录信息
dba_stmt_audit_opts 审计设置信息
dba_audit_object 对象审计结果信息
dba_audit_session 会话审计结果信息
dba_indexes 用户模式的索引信息
```

**user_开头**
```text
user_objects 用户对象信息
user_source 数据库用户的所有资源对象信息
user_segments 用户的表段信息
user_tables 用户的表对象信息
user_tab_columns 用户的表列信息
user_constraints 用户的对象约束信息
user_sys_privs 当前用户的系统权限信息
user_tab_privs 当前用户的对象权限信息
user_col_privs 当前用户的表列权限信息
user_role_privs 当前用户的角色权限信息
user_indexes 用户的索引信息
user_ind_columns 用户的索引对应的表列信息
user_cons_columns 用户的约束对应的表列信息
user_clusters 用户的所有簇信息
user_clu_columns 用户的簇所包含的内容信息
user_cluster_hash_expressions 散列簇的信息

```

**all_开头**

```sql
all_users 数据库所有用户的信息
all_objects 数据库所有的对象的信息
all_def_audit_opts 所有默认的审计设置信息
all_tables 所有的表对象信息
all_indexes 所有的数据库对象索引的信息

session_开头
session_roles 会话的角色信息
session_privs 会话的权限信息

index_开头
index_stats 索引的设置和存储信息

**伪表**
dual 系统伪列表信息
```
### 实例

::: details
实例
```sql
-- 查看视图中用到的表和视图
   SELECT NAME, REFERENCED_TYPE, REPLACE(TO_CHAR(WM_CONCAT(DISTINCT REFERENCED_NAME)), ',', chr(13))
     FROM SYS.ALL_DEPENDENCIES
    WHERE TYPE = 'VIEW'
      AND NAME = UPPER('视图名')
      AND REFERENCED_TYPE IN ('TABLE', 'VIEW')
      AND OWNER = '用户名'
 GROUP BY NAME, REFERENCED_TYPE
 ORDER BY REFERENCED_TYPE
;

-- 用到 某个表 的视图
   SELECT NAME, REFERENCED_TYPE, REPLACE(TO_CHAR(WM_CONCAT(DISTINCT REFERENCED_NAME)), ',', chr(13))
     FROM SYS.ALL_DEPENDENCIES
    WHERE TYPE = 'VIEW'
      AND REFERENCED_NAME = '表名'
      AND OWNER = '用户名'
 GROUP BY NAME, REFERENCED_TYPE
 ORDER BY REFERENCED_TYPE
;

-- 查看视图创建语句
SELECT * FROM all_views where VIEW_NAME = UPPER('视图名') AND OWNER = '用户名';

-- 查询建表语句
select dbms_metadata.get_ddl('TABLE',upper('tablename')) from dual;
```
:::

## 与MySQL区别

```text
1、oracle是大型数据库，mysql是小型数据库；
2、mysql是主键是支持自动增长类型的（在创建表的时候指定表的主键为auto_increment）,在插入记录时，不需要再指定该记录的主键值，mysql将自动增长；
3、oracle没有自动增长类型主键一般使用序列，在插入记录时，将序列号的下一个值付给该字段即可；
4、mysql可以用双引号包起字符串，而oracle只能用单引号包起。
5、处理分页逻辑不一样，mysql使用limit处理分页；而oracle使用rownum字段标明位置，并且只能用rowNum<100,不能用rowNum>80;
6、mysql定义的空字段里面可以有空的内容，但是oracle种非空字段不能有空的内；
7、两者都能使用like “%字符串%”,但是oracle中使用模糊查询后不能使用索引，速度不快；
8、两者给字段添加注释的方式不一样，

————————————————
原文链接：https://blog.csdn.net/z19950712/article/details/115478505
```


## Shell跑oracle脚本

---
```shell script
#! /bin/sh
logpath="log"
filepath="/home/ap/user"
#输入Oracle数据库的用户名密码等信息
DBINFO="username/password@ip:port/orcl"
if  ! -d ${logpath} ]
then
 mkdir log
fi
echo "`date +'%Y%m%d %H:%M:%S'`] Info: Begin to execute init sql!"
logfile="${logpath}/init_table_data_info.log"
#“${logfile} 2>&1”这里的意思就是把标准输出信息和错误输出信息都记录在init_table_data_info.log文件中
sqlplus -s ${DBINFO} << ! > ${logfile} 2>&1
whenever oserror exit 1;
whenever sqlerror exit 1;
@${filepath}/initTable.sql
@${filepath}/initTable2.sql
quit
!
if  $? -ne 0 ]
then
    echo "`date +'%Y%m%d %H:%M:%S'`] Error: Initialize initTable failed!"  >> ${logpath}
    exit 1
fi
echo "`date +'%Y%m%d %H:%M:%S'`] Initialize initTable  successed."  >> ${logpath}
```

## Oracle关联方式（执行计划）

为啥有说只有三种的<span style='color:red'>（待完善！！！）</span>
```text
Oracle的SQL优化器（Optimizer）在执行多表连接查询时，通常采用的连接算法有以下几种方式：
1、嵌套循环连接（NESTED LOOPS JOIN）
2、群集连接     (CLUSTER JOIN)
3、排序合并连接（SORT MERGE JOIN）
4、笛卡尔连接   (CARTESIAN JOIN)
5、哈希连接(HASH JOIN)
6、索引连接(INDEX JOIN)
```

多表之间的连接有三种方式：Nested Loops，Hash Join 和 Sort Merge Join. 下面来介绍三种不同连接的不同：

**NESTED LOOP**
>对于被连接的数据子集较小的情况，嵌套循环连接是个较好的选择。在嵌套循环中，内表被外表驱动，外表返回的每一行都要在内表中检索找到与它匹配的行，因此整个查询返回的结果集不能太大（大于1 万不适合），要把返回子集较小表的作为外表（CBO 默认外表是驱动表），而且在内表的连接字段上一定要有索引。当然也可以用ORDERED 提示来改变CBO默认的驱动表，使用USE_NL(table_name1 table_name2)可是强制CBO 执行嵌套循环连接。

>Nested loop一般用在连接的表中有索引，并且索引选择性较好的时候.

>步骤：确定一个驱动表(outer table)，另一个表为inner table，驱动表中的每一行与inner表中的相应记录JOIN。类似一个嵌套的循环。适用于驱动表的记录集比较小（<10000）而且inner表需要有有效的访问方法（Index）。需要注意的是：JOIN的顺序很重要，驱动表的记录集一定要小，返回结果集的响应时间是最快的。

**HASH JOIN**

> 散列连接是CBO 做大数据集连接时的常用方式，优化器使用两个表中较小的表（或数据源）利用连接键在内存中建立散列表，然后扫描较大的表并探测散列表，找出与散列表匹配的行。
  这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。但是在表很大的情况下并不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要有较大的临时段从而尽量提高I/O 的性能。
  也可以用USE_HASH(table_name1 table_name2)提示来强制使用散列连接。如果使用散列连接HASH_AREA_SIZE 初始化参数必须足够的大，如果是9i，Oracle建议使用SQL工作区自动管理，设置WORKAREA_SIZE_POLICY 为AUTO，然后调整PGA_AGGREGATE_TARGET 即可。

> Hash join在两个表的数据量差别很大的时候.

> 步骤：将两个表中较小的一个在内存中构造一个HASH表（对JOIN KEY），扫描另一个表，同样对JOIN KEY进行HASH后探测是否可以JOIN。适用于记录集比较大的情况。需要注意的是：如果HASH表太大，无法一次构造在内存中，则分成若干个partition，写入磁盘的temporary segment，则会多一个写的代价，会降低效率。

**SORT MERGE JOIN**
> 通常情况下散列连接的效果都比排序合并连接要好，然而如果行源已经被排过序，在执行排序合并连接时不需要再排序了，这时排序合并连接的性能会优于散列连接。可以使用USE_MERGE(table_name1 table_name2)来强制使用排序合并连接.
  Sort Merge join 用在没有索引，并且数据已经排序的情况.
  cost = (outer access cost * # of hash partitions) + inner access cost

> 步骤：将两个表排序，然后将两个表合并。通常情况下，只有在以下情况发生时，才会使用此种JOIN方式：
>> 1.RBO模式  
>>2.不等价关联(>,<,>=,<=,<>)  
>>3.HASH_JOIN_ENABLED=false  
>>4.数据源已排序

**三种连接工作方式比较**
> Hash join的工作方式是将一个表（通常是小一点的那个表）做hash运算，将列数据存储到hash列表中，从另一个表中抽取记录，做hash运算，到hash 列表中找到相应的值，做匹配。

> Nested loops 工作方式是从一张表中读取数据，访问另一张表（通常是索引）来做匹配，nested loops适用的场合是当一个关联表比较小的时候，效率会更高。

> Merge Join 是先将关联表的关联列各自做排序，然后从各自的排序表中抽取数据，到另一个排序表中做匹配，因为merge join需要做更多的排序，所以消耗的资源更多。 通常来讲，能够使用merge join的地方，hash join都可以发挥更好的性能。

**强制使用关联方式**
```sql
select /*+use_hash(t,t1) */ * from scott.dept t,scott.emp t1 where t.deptno=t1.deptno;
select /*+use_nl(t,t1) */ * from scott.dept t,scott.emp t1 where t.deptno=t1.deptno;
select /*+use_merge(t,t1) */ * from scott.dept t,scott.emp t1 where t.deptno=t1.deptno;
```

[原文链接](https://blog.csdn.net/tianlesoftware/article/details/5826546)


## 点状知识

### 匹配中文

```sql
使用uni()正则匹配不太好使

替换方案：chr(128) - chr(255) 可以匹配双字节字符
select regexp_replace('', '['||chr(128)|| '-' || chr(255) ||']', '-') from dual;
```

### 创建DBLink

```sql
-- Create database link 
create public database link <dblink名>
  connect to <用户名>
  IDENTIFIED BY <"密码">
  using '(DESCRIPTION =(ADDRESS_LIST =(ADDRESS =(PROTOCOL=TCP)(HOST=<ip>)(PORT=<端口>)))(CONNECT_DATA=(SERVICE_NAME=orcl)))';
```

### SQL并行

```sql
select /*+parallel(a, 16)*/ count(1) from dual a;
```

注：使用临时表with as时不能使用并行（比如：在存储过程中开启session并行），否则会导致结果不一致

### 中文排序方式


```sql
Oracle9i之前，中文是按照二进制编码进行排序的。
在oracle9i中新增了按照拼音、部首、笔画排序功能。设置NLS_SORT值

SCHINESE_RADICAL_M 按照部首(第一顺序)、笔划(第二顺序)排序
SCHINESE_STROKE_M 按照笔划(第一顺序)、部首(第二顺序)排序
SCHINESE_PINYIN_M 按照拼音排序

修改ORACLE字段的默认排序方式：
按拼音(默认)：
alter session set nls_sort = SCHINESE_PINYIN_M;
按笔画：
alter session set nls_sort = SCHINESE_STROKE_M;
按偏旁：
alter session set nls_sort = NLS_SORT=SCHINESE_RADICAL_M;

NLSSORT()，用来进行语言排序

示例:
SELECT * FROM TEAM ORDER BY NLSSORT(排序字段名,'NLS_SORT =SCHINESE_PINYIN_M')
```

### 数据中包含特殊符号需要转义

1. 执行语句前先执行 `set define off;` （去掉oracle自定义的字符含义，还原它本来的意思）
2. 使用ASCII编码对 & 进行转义 chr(38)  `select 'xxx?xxx=11' || chr(38) || 'xxx=33' from dual`
3. 不转义，直接字符串的形式写进去 `select 'xxx?xxx=11' || '&' || 'xxx=33' from dual`

### 数据泵导入导出（待完善）


**导入：待补充（TODO）**

**导入：首先我们需要知道导出用户和表空间的名字**

注意：1. 如果表空间不是只有一个，需要使用remap_tablespace指定到我们创建的表空间 2. 单个表空间文件最大32G

> 所以拿到导出log文件是非常有必要的

```sql
-- 创建表空间  UNLIMITED指定不限制最大表空间
create TABLESPACE DSY datafile 'E:\OracleData\tablespace\DATAS.dbf' size 50m autoextend on next 50m MAXSIZE UNLIMITED extent management local; 
-- 删除表空间
drop TABLESPACE DSY including contents and datafiles cascade constraints;
-- 查询表空间
select * from dba_tablespaces;


-- 管理员登录，创建新用户(用户名一定要大写)，分配已创建好的表空间
create user FZL identified BY banana default TABLESPACE DSY;
-- 删除用户带级联
drop user FZL cascade;


-- 授权
Grant dba to FZL with admin option;


-- 查询dup存放目录目录    注意：后面的E盘下面的dpdump 必须把你要导入的xxx.dmp文件放进该文件夹  DATA_PUMP_DIR
select * from dba_directories;
-- 数据泵导入数据 (CMD命令行   DATA_PUMP_DIR为上面查出的目录名  如果有其他表空间的，需要使用remap_tablespace指定到我们创建的表空间)
impdp FZL remap_tablespace=MOF:DSY directory=DATA_PUMP_DIR dumpfile=FZL.DMP logfile=impdp.log -- FULL=YES


-- 增加指定表空间文件（单个表空间文件最大32G，需要扩充）
ALTER TABLESPACE DSY ADD DATAFILE 'E:\OracleData\tablespace\DATAS01.dbf' SIZE 100M AUTOEXTEND ON NEXT 50M  ;
```


### 解决本地Oracle服务内存占用过高

**Oracle安装时，为均衡电脑性能和数据库性能，默认内存大小为物理内存的1/8**

1. 用dba身份进入oracle
2. show parameter sga; --显示内存分配情况
3. alter system set sga_target=1024m scope=spfile;-修改target大小 //这个值必须小于等于sga_max_size ，否则库会起不来；
4. alter system set sga_max_size=1024m scope=spfile; --修改最大占用内存的大小
5. 修改后重启Oracle服务
6. 附：Oracle服务介绍 [原文链接](https://blog.csdn.net/Ren_gw/article/details/84592715)
    - Oracle ORCL VSS Writer Service：Oracle卷映射拷贝写入服务，VSS（Volume Shadow Copy Service）能够让存储基础设备（比如磁盘，阵列等）创建高保真的时间点映像，即映射拷贝（shadow copy）。它可以在多卷或者单个卷上创建映射拷贝，同时不会影响到系统的系统能。<span style="color:red">（非必须启动）</span>
    - OracleDBConsoleorcl：Oracle数据库控制台服务，orcl是Oracle的实例标识，默认的实例为orcl。在运行Enterprise Manager（企业管理器OEM）的时候，需要启动这个服务。<span style="color:red">（非必须启动）</span>
    - OracleJobSchedulerORCL：Oracle作业调度（定时器）服务，ORCL是Oracle实例标识。<span style="color:red">（非必须启动）</span>
    - OracleMTSRecoveryService：服务端控制。该服务允许数据库充当一个微软事务服务器MTS、COM/COM+对象和分布式环境下的事务的资源管理器。<span style="color:red">（非必须启动）</span>
    - OracleOraDb11g_home1ClrAgent：Oracle数据库  .NET扩展服务的一部分。 <span style="color:red">（非必须启动）</span>
    - OracleOraDb11g_home1TNSListener：监听器服务，服务只有在数据库需要远程访问的时候才需要。<span style="color:red">（非必须启动但很常用）</span>
    - OracleServiceORCL：数据库服务(数据库实例)，是Oracle核心服务，该服务是数据库启动的基础， 只有该服务启动，Oracle数据库才能正常启动。<span style="color:red">(必须启动)</span>


### 数据插入慢的问题

1. 有个九百多万数据的表需要重新抽数（抽数速度极其慢，后发现是索引导致的，不清楚是索引有问题还是正常现象（索引增加查询速率但影响insert、update、delete效率），<span style='color:red;font-weight:bold'>应该先删除索引再抽数</span>）
	> 没删除索引前的效率： 【345430 条数据花费 1406s】【345430 条数据花费1301s】  
	> 删除后的效率：【345508条数据花费 64s】【345482 条数据花费 7.248s】【345508 条数据34.466s】【datax：1641410条数据465s】
