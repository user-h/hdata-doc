---
title: SQL非常规用法
date: 2022-06-12 22:15:30
permalink: /pages/e02b49/
categories:
  - 数据库
tags:
  - 记录一些不太常见，但非常有用的SQL写法
---


## SQL

#### 递归CTEs

> 递归CET可用于查询组织结构图、文件系统、网页之间的链接图等分层数据

递归CTE三部分：

1. 锚构件（定点成员）：返回 CTE 的基本结果的初始查询
2. 递归成员：引用 CTE 的递归查询。这是所有与锚构件的联盟
3. 停止递归构件的终止条件（隐式的；当上一个调用中未返回行时，递归将停止。）

::: details
示例
```sql
-- 测试表建表语句
CREATE TABLE TABLENAME(
  ItemId INT PRIMARY KEY,
  ParentItemId INT,
  ItemName VARCHAR(200)
)

-- 插入数据
insert into tablename values(2,0,'管理费用');
insert into tablename values(3,0,'销售费用');
insert into tablename values(4,0,'财务费用');
insert into tablename values(5,0,'生产成本');
insert into tablename values(35,5,'材料');
insert into tablename values(36,5,'人工');
insert into tablename values(37,5,'制造费用');
insert into tablename values(38,35,'原材料');
insert into tablename values(39,35,'主要材料');
insert into tablename values(40,35,'间辅材料');
insert into tablename values(41,36,'工资');
insert into tablename values(42,36,'福利');
insert into tablename values(43,2,'管理费用子项');
insert into tablename values(113,43,'管理费用子项的子项');

-- 递归 CTE 语句（在 MySQL8.0 尝试不好使，在 Oracle 是好使的）
WITH tablenameTemp(ItemId, ItemName, levelno) AS (
SELECT ItemId, ItemName, 0 as levelno
  FROM tablename
 WHERE ParentItemId = 0
UNION ALL
SELECT T1.ItemId, T1.ItemName, T2.levelno + 1 as levelno
  FROM tablename T1
 INNER JOIN tablenameTemp T2
    ON T1.parentitemid = T2.itemid
)
SELECT * FROM tablenameTemp

```

[参考链接](https://blog.csdn.net/nayi_224/article/details/82147786?spm=1001.2014.3001.5506)
:::

[很牛的用法](https://explainextended.com/2013/12/31/happy-new-year-5/)

<code-group>
  <code-block title="PostgreSQL" active>
  ```sql
  WITH    RECURSIVE
          q (r, i, rx, ix, g) AS
          (
          SELECT  r::DOUBLE PRECISION * 0.02, i::DOUBLE PRECISION * 0.02, .0::DOUBLE PRECISION, .0::DOUBLE PRECISION, 0
          FROM    generate_series(-60, 20) r, generate_series(-50, 50) i
          UNION ALL
          SELECT  r, i, CASE WHEN ABS(rx * rx + ix * ix) <= 2 THEN rx * rx - ix * ix END + r, CASE WHEN ABS(rx * rx + ix * ix) <= 2 THEN 2 * rx * ix END + i, g + 1
          FROM    q
          WHERE   rx IS NOT NULL
                  AND g < 99
          )
  SELECT  ARRAY_TO_STRING(ARRAY_AGG(s ORDER BY r), '')
  FROM    (
          SELECT  i, r, SUBSTRING(' .:-=+*#%@', MAX(g) / 10 + 1, 1) s
          FROM    q
          GROUP BY
                  i, r
          ) q
  GROUP BY
          i
  ORDER BY
          i
  ```
  </code-block>

  <code-block title="2">
  ```sql
  WITH    RECURSIVE
          q (r, i, rx, ix, g) AS
          (
          SELECT  r::DOUBLE PRECISION * 0.04, i::DOUBLE PRECISION * 0.04, .0::DOUBLE PRECISION, .0::DOUBLE PRECISION, 0
          FROM    generate_series(-40, 20) r, generate_series(-40, 20) i
          UNION ALL
          SELECT  r, i, CASE WHEN ABS(rx * rx + ix * ix) <= 1E8 THEN rx * rx - ix * ix END + r, CASE WHEN ABS(rx * rx + ix * ix) <= 2 THEN ABS(2 * rx * ix) END + i, g + 1
          FROM    q
          WHERE   rx IS NOT NULL
                  AND g < 99
          )
  SELECT  ARRAY_TO_STRING(ARRAY_AGG(s ORDER BY r), '')
  FROM    (
          SELECT  i, r, SUBSTRING(' .:-=+*#%@', MAX(g) / 10 + 1, 1) s
          FROM    q
          GROUP BY
                  i, r
          ) q
  GROUP BY
          i
  ORDER BY
          i
  ```
  </code-block>

  <code-block title="3">
  ```sql
  WITH    RECURSIVE
          q (r, i, rx, ix, g) AS
          (
          SELECT  r::DOUBLE PRECISION * 0.000001, i::DOUBLE PRECISION * 0.000001,
                  r::DOUBLE PRECISION * 0.000001, i::DOUBLE PRECISION * 0.000001,
                  0
          FROM    generate_series(-40, 40) r, generate_series(-50, 50) i
          UNION ALL
          SELECT  r, i,
                  CASE WHEN ABS(rx * rx + ix * ix) < 1E8 THEN rx * rx - ix * ix END + 0,
                  CASE WHEN ABS(rx * rx + ix * ix) < 1E8 THEN 2 * rx * ix END + 1,
                  g + 1
          FROM    q
          WHERE   rx IS NOT NULL
                  AND g < 99
          )
  SELECT  ARRAY_TO_STRING(ARRAY_AGG(s ORDER BY r), '')
  FROM    (
          SELECT  i, r, SUBSTRING(' .:-=+*#%@', MAX(g) / 10 + 1, 1) s
          FROM    q
          GROUP BY
                  i, r
          ) q
  GROUP BY
          i
  ORDER BY
          i
  ```
  </code-block>
  
  <code-block title="4">
  ```sql
  WITH    RECURSIVE
          q (r, i, rx, ix, g) AS
          (
          SELECT  r::DOUBLE PRECISION * 0.0002, i::DOUBLE PRECISION * 0.0002,
                  r::DOUBLE PRECISION * 0.0002, i::DOUBLE PRECISION * 0.0002,
                  0
          FROM    generate_series(-200, -120) r, generate_series(0, 100) i
          UNION ALL
          SELECT  r, i,
                  CASE WHEN ABS(rx * rx + ix * ix) < 1E8 THEN rx * rx - ix * ix END - 0.70176,
                  CASE WHEN ABS(rx * rx + ix * ix) < 1E8 THEN 2 * rx * ix END + 0.3842,
                  g + 1
          FROM    q
          WHERE   rx IS NOT NULL
                  AND g < 99
          )
  SELECT  ARRAY_TO_STRING(ARRAY_AGG(s ORDER BY r), '')
  FROM    (
          SELECT  i, r, SUBSTRING(' .:-=+*#%@', MAX(g) / 10 + 1, 1) s
          FROM    q
          GROUP BY
                  i, r
          ) q
  GROUP BY
          i
  ORDER BY
          i
  ```
  </code-block>
    
  <code-block title="5">
  ```sql
  WITH    RECURSIVE
          q (r, i, rx, ix, g) AS
          (
          SELECT  x + r::DOUBLE PRECISION * step, y + i::DOUBLE PRECISION * step,
                  x + r::DOUBLE PRECISION * step, y + i::DOUBLE PRECISION * step,
                  0
          FROM    (
                  SELECT  0.25 x, -0.55 y, 0.002 step, r, i
                  FROM    generate_series(-40, 40) r
                  CROSS JOIN
                          generate_series(-40, 40) i
                  ) q
          UNION ALL
          SELECT  r, i,
                  CASE WHEN (rx * rx + ix * ix) < 1E8 THEN (rx * rx + ix * ix) ^ 0.75 * COS(1.5 * ATAN2(ix, rx)) END - 0.2,
                  CASE WHEN (rx * rx + ix * ix) < 1E8 THEN (rx * rx + ix * ix) ^ 0.75 * SIN(1.5 * ATAN2(ix, rx)) END,
                  g + 1
          FROM    q
          WHERE   rx IS NOT NULL
                  AND g < 99
          )
  SELECT  ARRAY_TO_STRING(ARRAY_AGG(s ORDER BY r), '')
  FROM    (
          SELECT  i, r, SUBSTRING(' .:-=+*#%@', MAX(g) / 10 + 1, 1) s
          FROM    q
          GROUP BY
                  i, r
          ) q
  GROUP BY
          i
  ORDER BY
          i
  ```
  </code-block>
    
</code-group>

#### 窗口函数 rowsbetween、rangebetween 的使用

<code-group>
  <code-block title="rangebetween" active>
  ```sql
  -- 待补充
  ```
  </code-block>

  <code-block title="rowsbetween">
  ```sql
  SELECT CODE
  ,TO_CHAR(WM_CONCAT(CODE) OVER(PARTITION BY LEVELNO ORDER BY CODE )) AS test1
  --,TO_CHAR(WM_CONCAT(CODE) OVER(PARTITION BY LEVELNO ORDER BY CODE rows between 1 preceding and 3 following)) AS test1   -- 当前之前一行到后面三行
  --,TO_CHAR(WM_CONCAT(CODE) OVER(PARTITION BY LEVELNO ORDER BY CODE rows between UNBOUNDED PRECEDING and CURRENT ROW)) AS test2  -- 区间第一行到当前行
  ,TO_CHAR(WM_CONCAT(CODE) OVER(PARTITION BY LEVELNO ORDER BY CODE rows between CURRENT ROW and UNBOUNDED FOLLOWING)) AS test3  -- 当前行区间最后一行
  FROM AD_TABLE
  ```
  </code-block>
</code-group>

#### 博客：10个SQL杀手级特性

[原文地址](https://n3xtchen.github.io/n3xtchen/2017/02/13/10-sql-tricks-that-you-didnt-think-were-possible)

#### 需要避免的问题

##### 1. 视图

个人感觉：视图用不好会导致视图泛滥、重复关联，造成查询效率极低的情况。

看到别人说的很有道理：[原文链接](https://www.oschina.net/question/222929_61696?p=2)
> 1. 做个一般的业务系统，完全可以不用视图，如果你要用视图，只能说明你表没设计好，那就继续理解业务优化表设计去（有的人可能要喷这句，但实际情况就是要连表多表的SQL都是复杂的后台数据综合分析系统才需要，这样的SQL整个系统也要不了几句，再说现在不是有google的分析工具么，已经可以代替大部分自己要做的分析，只要网页嵌个js代码就行）。
> 2. 视图一般都只有查询能力，和真正的表并不一样。而许多公司底层DAO都是BaseDao，然后各个表去继承的形式，这样就导致如果你有视图，肯定也要有dao，然而一继承这个BaseDao，就会暴露出视图根本就不支持的增删改能力。而为了DAO层统一性，很多情况下都是不允许你自己去写DAO的，你继承又暴露出你根本不支持的功能。你现在用的爽（因为你知道，所有只用了查），而后来者对此一无所知，他就按照公司的习惯，同时你也暴露出来增删改，他就去增删改，结果报错。
> 3. 我们这次要改表，可我并不知道哪些视图依赖此表，好吧，我改表了，我的业务完成了；你的视图依赖了此表，但这是你很久前就做好的模块，你也不管。结果呢？大家都以为没事一切ok，当真的用到你做的模块时，却报错。你大吼“这是我以前做的，都上线3个月了，一直好好的。而这次谁都没改，怎么可能报错，反正不是我的错”，那谁的错？只是因为你的视图依赖的表结构改了，而你没有重新执行此视图的代码。
