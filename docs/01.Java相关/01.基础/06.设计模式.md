---
title: 设计模式
date: 2022-07-10 16:30:55
permalink: /pages/bdceb5/
---

## 类间关系

---

**耦合度从弱到强**

```mermaid
graph LR
	A[依赖<br>Dependence] --> B[关联<br>Association] --> C[聚合<br>Aggregation] --> D[组合<br>Composition] --> E[泛化<br>Generalization] --> F[实现<br>Realization]
```

#### 1、依赖（Dependence）

含义：体现了类之间的弱作用关系，是一种临时性的使用关系，通常用虚线+箭头表示。

举例：依赖关系是类之间最弱的关系，比如，类A的一些方法参数中使用了类B的实例；类A的一些方法逻辑中调用了类B的方法或变量等等。

#### 2、关联（Association）

含义：体现了类之间的强作用关系，通常用实线或实线+箭头表示，这里的关联关系指的是一般关联关系，后面的聚合和组合也属于关联关系。

举例：关联关系是类之间的引用关系，生活中的常见，比如有：手机和充电线，老师和学生，生产者和消费者等。可以通过成员变量来实现关联关系，比如类A中使用了类B的对象引用，A和B之间就是一种关联关系。

类型：一般关联关系又可以分为单向关联、双向关联、自关联，画图表示。

#### 3、聚合（Aggregation）

含义：体现了类之间的强作用关系，也属于关联关系的一种，是整体和局部之间的关系，是 has-a 的关系，通常用实线+虚心菱形箭头表示。

举例：聚合关系强调了整体和局部的关系，比如学校和教师，工厂和工人等，注意的是局部可以独立于整体而存在，比如工厂没了但工人还是可以存在的！通过成员属性来实现聚合关系。

#### 4、组合（Composition）

含义：体现了类之间的强作用关系，也属于关联关系的一种，也是整体和局部之间的关系，是 cxmtains-a 的关系，通常用实线+实心菱形箭头表示。

举例：组合关系是一种耦合度更高的聚合关系，整体对象可以控制部分对象的生命周期，部分对象不能脱离整体对象而存在，比如电脑和CPU，如果CPU没了，电脑就失去了基本的运算能力等同于电脑报废。

#### 5、泛化（Generalization）

含义：体现了类之间的继承关系，是一种耦合度最高的关系，是 is-a 的关系，通常用实线+空心三角箭头表示。

举例：泛化关系强调了一般与特殊的关系，通过Java的类继承机制实现类之间的泛化关系，比如：手机工厂，与华为手机工厂，小米手机工厂之间的关系。

#### 6、实现（Realization）

含义：体现了接口和类之间的关系，通常用虚线+空心三角箭头表示。

举例：实现关系，通过Java的实现机制实现的，比如：手机工厂接口，与华为手机工厂实现类，小米手机工厂实现类之间的关系。


## 六(七)大设计原则

---

#### 一、单一职责原则

**注意事项和细节**
1. 降低类的复杂度，一个类只负责一个职责
2. 提高类的可读性，可维护性
3. 降低变更引起的风险
4. 通常情况下，我们应当遵守单一职责原则 ，只有逻辑足够简单，才能在代码级违反单一职责原则；只有类中方法足够少，可以在方法级别保持单一职责原则

#### 二、接口隔离原则

**客户端不应该依赖它不需要的接口， 即一个类对另一个类的依赖应该建立在最小的接口上**

```mermaid  
classDiagram  
	class interface01{
	  <<interface>>
	  String str
	  +void operation1()
	  +void operation2()
	  +void operation3()
	  +void operation4()
	  +void operation5()
	}
	class A{
	  +void operation1()
	  +void operation2()
	  +void operation3()
	}  
	class B{
	  +void operation1()
	  +void operation2()
	  +void operation3()
	}  
	class C{
	  +void operation1()
	  +void operation4()
	  +void operation5()
	}  
	class D{
	  +void operation1()
	  +void operation4()
	  +void operation5()
	}  
  
	A ..> interface01 : 依赖
	C ..> interface01 : 依赖
	B ..|> interface01 : 实现
	D ..|> interface01 : 实现
```

**问题：** 类 A 通过接口依赖类 B， 类 C 通过接口依赖类 D， 如果接口对于类 A 和类 C 来说不是最小接口， 那么**类 B 和类 D 必须去实现他们不需要的方法**

**解决：** 将接口拆分为独立的几个接口(这里我们拆分成 3 个接口)

```mermaid  
classDiagram  
	class interface01{
	  <<interface>>
	  +void operation1()
	}
	class interface02{
	  <<interface>>
	  +void operation2()
	  +void operation3()
	}
	class interface03{
	  <<interface>>
	  +void operation4()
	  +void operation5()
	}
	class A{
	  +void operation1()
	  +void operation2()
	  +void operation3()
	}  
	class B{
	  +void operation1()
	  +void operation2()
	  +void operation3()
	}  
	class C{
	  +void operation1()
	  +void operation4()
	  +void operation5()
	}  
	class D{
	  +void operation1()
	  +void operation4()
	  +void operation5()
	}  
  
	A ..> interface01 : 依赖
	A ..> interface02 : 依赖
	C ..> interface01 : 依赖
	C ..> interface03 : 依赖
	B ..|> interface01 : 实现
	B ..|> interface02 : 实现
	D ..|> interface01 : 实现
	D ..|> interface03 : 实现
```

#### 三、依赖倒转原则

依赖倒转原则(Dependence Inversion Principle)是指:

1. 高层模块不应该依赖低层模块， 二者都应该依赖其抽象
2. 抽象不应该依赖细节， 细节应该依赖抽象
3. 依赖倒转(倒置)的中心思想是面向接口编程
4. 依赖倒转原则是基于这样的设计理念： 相对于细节的多变性， 抽象的东西要稳定的多。 以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。 在 java 中， 抽象指的是接口或抽象类， 细节就是具体的实现类
5. 使用接口或抽象类的目的是制定好规范， 而不涉及任何具体的操作， 把展现细节的任务交给他的实现类去完成

问题(不知道图画的对不对)：如果获取的对象是微信，就要新增类，Persion也要新增相应接收方法

```mermaid    
classDiagram  
    class Email{
      +String getInfo()
    }
	
	class Persion{
      +void receive(Recever rec)
    }
	
	Persion ..>  Email: 依赖
```

解决思路: 引入一个抽象的接口 IReceiver

```mermaid    
classDiagram  
	class IReceiver{
	 <<interface>>
      +String getInfo()
    }
	
    class Email{
      +String getInfo()
    }

    class WeiXin{
      +String getInfo()
    }
	
	class Persion{
      +void receive(Recever rec)
    }
	
	Email ..|> IReceiver : 实现
	WeiXin ..|> IReceiver : 实现
	Persion ..>  IReceiver: 依赖
```

依赖关系传递的三种方式

1. 接口传递
```java
ChangHong changHong = new ChangHong();  //实现ITV接口
OpenAndClose openAndClose = new OpenAndClose();  //实现IOpenAndClose接口
openAndClose.open(changHong);  //IOpenAndClose方法参数为ITV
```
2. 构造方法传递
```java
OpenAndClose openAndClose = new OpenAndClose(changHong);  //实现IOpenAndClose接口 且 构造参数为ITV
openAndClose.open();  //调用ITV的play方法
```
3. setter 方式传递
```java
OpenAndClose openAndClose = new OpenAndClose();  //实现IOpenAndClose接口
openAndClose.setTv(changHong);  //set方法参数为ITV
openAndClose.open();  //调用ITV的play方法
```

注意事项:

1) 低层模块尽量都要有抽象类或接口， 或者两者都有， 程序稳定性更好.  
2) 变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间， 就存在一个缓冲层， 利于程序扩展和优化  
3) 继承时遵循里氏替换原则

#### 四、里式替换原则

**OO 中的继承性的思考和说明:**

1) 继承包含这样一层含义： 父类中凡是已经实现好的方法， 实际上是在设定规范和契约子类如果对这些方法任意修改, 就会对继承体系造成破坏  
2) 继承在给程序设计带来便利的同时， 也带来了弊端。会给程序带来侵入性， 程序的可移植性降低，增加对象间的耦合性(修改父类, 子类可能出现故障)
3) 问题提出： 在编程中， 如何正确的使用继承? => 里氏替换原则

**基本介绍:**

1) 1988 年， 由麻省理工学院的以为姓里的女士提出
2) **理想状态**: 所有引用基类的地方必须能透明地使用其子类的对象
3) **使用继承时**: 子类中尽量不要重写父类的方法
4) 继承实际上让两个类耦合性增强了，适当的情况下: 可以通过**聚合， 组合， 依赖**来解决问题

#### 五、开闭原则ocp

基本介绍:

1) 开闭原则（Open Closed Principle） 是编程中最基础、 最重要的设计原则
2) 一个软件实体如类， 模块和函数应该对扩展开放(对提供方)， 对修改关闭(对使用方)。 用抽象构建框架， 用实现扩展细节
3) 当软件需要变化时， 尽量通过扩展软件实体的行为来实现变化， 而不是通过修改已有的代码来实现变化。
4) 编程中遵循其它原则， 以及使用设计模式的目的就是遵循开闭原则

```mermaid    
classDiagram  
	class Shape{
	 <<abstract>>
    }
	
    class Cicle{
    }

    class Retangle{
    }
	
	class GraphicEditor{
      +void drawShape()
      +void drawCicle()
      +void drawRetangle()
    }
	
	Cicle ..|> Shape : 实现
	Retangle ..|> Shape : 实现
	GraphicEditor ..> Cicle : 依赖
	GraphicEditor ..> Retangle : 依赖
```

优缺点：好理解易操作；违反了开闭原则；新增加一个三角形类，要修改很多地方（如：新加Trlangle类 GraphicEditor类增加方法 drawShape方法增加分支）

```mermaid    
classDiagram  
	class Shape{
	  <<abstract>>
	  +void draw()
    }
	
    class Cicle{
	  +void draw()
    }

    class Retangle{
	  +void draw()
    }
	
	class OtherShape{
	  +void draw()
    }
	
	class GraphicEditor{
      +void drawShape(Shape s)
    }
	
	Cicle ..|> Shape : 实现
	Retangle ..|> Shape : 实现
	OtherShape ..|> Shape : 实现
	GraphicEditor ..> Shape : 依赖
```

#### 六、迪米特法则(最少知道原则)

基本原则:
1) 一个对象应该对其他对象保持最少的了解
2) 类与类关系越密切， 耦合度越大
3) 迪米特法则(Demeter Principle)又叫最少知道原则， 即一个类对自己依赖的类知道的越少越好。 也就是说， 对于被依赖的类不管多么复杂， 都尽量将逻辑封装在类的内部。 对外除了提供的 public 方法， 不对外泄露任何信息
4) 迪米特法则还有个更简单的定义： **只与直接的朋友通信**
5) **直接的朋友**： 每个对象都会与其他对象有耦合关系， 只要两个对象之间有耦合关系， 我们就说这两个对象之间是朋友关系。 耦合的方式很多， 依赖， 关联， 组合， 聚合等。 其中， 我们称出现成员变量， 方法参数， 方法返回值中的类为直接的朋友， 而出现在局部变量中的类不是直接的朋友。 也就是说， 陌生的类最好不要以局部变量的形式出现在类的内部

注意事项

1) 迪米特法则的核心是降低类之间的耦合
2) 但是注意： 由于每个类都减少了不必要的依赖， 因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系

#### 七？合成复用原则

基本介绍：原则是尽量使用合成/聚合的方式， 而不是使用继承 

#### 核心思想

1. 找出应用中可能需要变化之处， 把它们独立出来， 不要和那些不需要变化的代码混在一起。
2. 针对接口编程， 而不是针对实现编程。
3. 为了交互对象之间的松耦合设计而努力


## 23个设计模式

---

### 设计模式入门

#### 设计原则

1. 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。
2. 针对接口编程，而不是针对实现编程。
3. 多用组合，少用继承
4. 为了交互对象之间的松耦合设计而努力

#### 元认知

[![元认知](https://s1.ax1x.com/2022/07/10/jyGv5j.png)](https://imgtu.com/i/jyGv5j)

#### 要点

- 知道OO基础，并不足以让你设计出良好的OO系统。
- 良好的OO设计必须具备可复用、可扩充、可维护三个特性。
- 模式可以让我们建造出具有良好O0设计质量的系统。
- 模式被认为是历经验证的OO设计经验。
- 模式不是代码，而是针对设计问题的通用解决方案。你可把它们应用到特定的应用中。
- 模式不是被发明，而是被发现。
- 大多数的模式和原则，都着眼于软件变化的主题。
- 大多数的模式都允许系统局部改变独立于其他部分。
- 我们常把系统中会变化的部分抽出来封装。
- 模式让开发人员之间有共享的语言，能够最大化沟通的价值。

### 策略模式（Strategy Pattern）

<span style='color:red'>**策略模式**定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</span>

#### 鸭子飞和叫
1. 为了给鸭子增加飞行能力
> 问题：在超类增加方法导致橡皮鸭也会飞了  
> 解决方案：在子类中覆盖掉父类方法，又会导致其他问题（一旦创建新的鸭子类，就必须检查飞行和叫的方法）
```mermaid    
classDiagram  
	class Duck{
	  +quack()
	  +swim()
	  +display()
	  +fly()
    }
	
    class MallardDuck{
	  +display("绿头")
    }

    class RedHeadDuck{
	  +display("红头")
    }
	
	class RubberDuck{
	  +display("橡皮鸭")
	  +quack("覆盖为吱吱叫")
    }
	
	Duck <|-- MallardDuck : 继承
	Duck <|-- RedHeadDuck : 继承
	Duck <|-- RubberDuck  : 继承
```

> 使用接口呢，会导致
> 1. 代码不能复用
> 2. 飞行动作有区别，就要每个类的方法都有不同的实现

```mermaid    
classDiagram  
	class Duck{
	  +swim()
	  +display()
    }
	
	class Flyable{
	  <<Interface>>
	  +fly()
	}
	
	class Quackable{
	  <<Interface>>
	  +Quack()
	}
	
    class MallardDuck{
	  +fly()
	  +display()
    }

    class RedHeadDuck{
	  +fly()
	  +display()
    }
	
	class RubberDuck{
	  +display()
	  +quack()
    }
	
	Duck <|-- MallardDuck : 继承
	Flyable <|.. MallardDuck : 实现
	Quackable <|.. MallardDuck : 实现
	Duck <|-- RedHeadDuck : 继承
	Flyable <|.. RedHeadDuck : 实现
	Quackable <|.. RedHeadDuck : 实现
	Duck <|-- RubberDuck  : 继承
	Quackable <|.. RubberDuck  : 实现
```

> 针对接口编程 真正含义为针对超类编程。即Animal animal = new Dog()的形式
> 优点：
> 1. 飞行和叫的动作可以被其他对象复用
> 2. 可以新增行为，不会影响到行为类，也不会影响到鸭子类
> 
> 缺点：构造器实例化对象，是对具体实现编程，有待改进

```mermaid    
classDiagram  
	class Duck{
	  FlyBehavior flyBehavior
	  QuackBehavior quackBehavior
	  +performFly(flyBehavior.fly)
	  +performQuack()
	  +swim()
	  +display()
    }
	
	class FlyBehavior{
	  <<Interface>>
	  +fly()
	}
	
	class FlyWithWings{
	  +fly("实现鸭子飞行")
	}
	
	class FlyNoWay{
	  +fly("什么都不做")
	}
	
	class QuackBehavior{
	  <<Interface>>
	  +quack()
	}
	
	class Quack{
	  +quack("呱呱叫")
	}
	
	class SQuack{
	  +quack("吱吱叫")
	}
	
	class MuteQuack{
	  +quack("什么也不做")
	}
	
    class MallardDuck{
	  +MallardDuck("实例化飞行和叫声类")
	  +display()
    }

    class RedHeadDuck{
	  +RedHeadDuck("实例化飞行和叫声类")
	  +display()
    }
	
	class RubberDuck{
	  +RubberDuck("实例化飞行和叫声类")
	  +display()
    }
	
	FlyBehavior <|.. FlyWithWings : 实现
	FlyBehavior <|.. FlyNoWay : 实现
	QuackBehavior <|.. Quack : 实现
	QuackBehavior <|.. SQuack : 实现
	QuackBehavior <|.. MuteQuack : 实现
	
	Duck o-- FlyBehavior : 聚合
	Duck o-- QuackBehavior : 聚合
	
	Duck <|-- MallardDuck : 继承
	Duck <|-- RedHeadDuck : 继承
	Duck <|-- RubberDuck  : 继承
```

<span style='color:red'>**改进：** 创建 FlyBehavior、QuackBehavior 的 get、set 方法，使运行时可以动态的设定其行为，即在创建鸭子对象时传入行为对象来设置其行为。（有点类似于函数编程通过参数传入一段逻辑的感觉？？？）</span>

#### 小游戏：动作冒险游戏

有游戏角色和使用武器行为的类，每个角色一次只能使用一种武器，但是可以在游戏过程中换武器。

```mermaid
classDiagram  
	class Character{
	  <<abstract>>
	  WeaponBehavior weapon
	  +fight() void
	  +setWeapon(WeaponBehavior w) void
    }
	class King{
	  +fight() void
    }
	class Queen{
	  +fight() void
    }
	class Troll{
	  +fight() void
    }
	class Knight{
	  +fight() void
    }
	
	class WeaponBehavior{
	  <<Interface>>
	  +useWeapon() void
    }
	class KnifeBehavior{
	  +useWeapon("使用匕首刺杀") void
    }
	class BowAndArrowBehavior{
	  +useWeapon("使用弓箭射击") void
    }
	class AxeBehavior{
	  +useWeapon("使用斧头劈砍") void
    }
	class SwordBehavior{
	  +useWeapon("使用宝剑挥舞") void
    }
	
	Character <|-- King : 继承
	Character <|-- Queen : 继承
	Character <|-- Troll : 继承
	Character <|-- Knight : 继承
	
	WeaponBehavior <|.. KnifeBehavior : 实现
	WeaponBehavior <|.. BowAndArrowBehavior : 实现
	WeaponBehavior <|.. AxeBehavior : 实现
	WeaponBehavior <|.. SwordBehavior : 实现
	
	Character --> WeaponBehavior
```

### 观察者模式（Observer）

<span style='color:red'>**观察者模式** 定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</span>

简单来说：观察者模式 = 出版者<span style='color:#CCCCCC'>（主题 Subject）</span> + 订阅者<span style='color:#CCCCCC'>（观察者 Observer）</span> 

#### 气象监测应用

1. 问题描述

> 此系统中的三个部分是气象站（获取实际气象数据的物理装置）、WeatherData对象(追踪来自气象站的数据，并更新布告板)和布告板（显示目前天气状况给用户看）

```mermaid  
classDiagram  
    class WeatherData{
	  + getTempreature() float
	  + getHumidity() float
	  + getPressure() float
	  + measurementsChanged("气象测量更新时调用")
	}
```

2. 错误示范

> 错误示范：实现 measurementsChanged 方法
> 1. 这里针对具体实现编程，而非针对接口
> 2. 对于每个新的布告板，我们都得修改代码
> 3. 无法在运行时动态增加或删除布告板
> 4. 没有封装改变的部分

```java
public class WeatherData{
    public void measurementsChanged() {
        // 通过getter方法获取值
        float temp = getTempreature();
        float humidity = getHumidity();
        float pressure = getPressure();

        // 更新3个布告板
        currentConditionsDisplay.update(temp, humidity, pressure);
        statisticsDisplay.update(temp, humidity, pressure);
        forecastDisplay.update(temp, humidity, pressure);

        // 其他方法
    }
}
```

3. 松耦合

- 当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。
- 观察者模式提供了一种对象设计，让主题和观察者之间松耦合。
- 松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低。

4. 类图设计

```mermaid  
classDiagram  
    class Subject{
	  <<interface>>
	  + registerObserver()
	  + removeObserver()
	  + notifyObserver()
	}
	
	class WeatherData{
	  + registerObserver()
	  + removeObserver()
	  + notifyObserver()
	  
	  + getTempreature() float
	  + getHumidity() float
	  + getPressure() float
	  + measurementsChanged()
	}
	
	class Observer {
	  <<interface>>
	  + update()
	}
	class DisplayElement{
	  <<interface>>
	  + display()
	}
	class CurrentConditionsDisplay{
	  + update()
	  + display("显示当前观测值")
	}
	class StatisticsDisplay{
	  + update()
	  + display("最大、最小、平均值")
	}
	class ForecastDisplay{
	  + update()
	  + display("天气预报")
	}
	class ThirdPartyDisplay{
	  + update()
	  + display("基于观测值其他内容")
	}
	
	Subject <|.. WeatherData : 实现
	Observer <|.. CurrentConditionsDisplay : 实现
    Observer <|.. StatisticsDisplay : 实现
    Observer <|.. ForecastDisplay : 实现
    Observer <|.. ThirdPartyDisplay : 实现
	DisplayElement <|.. CurrentConditionsDisplay : 实现
    DisplayElement <|.. StatisticsDisplay : 实现
    DisplayElement <|.. ForecastDisplay : 实现
    DisplayElement <|.. ThirdPartyDisplay : 实现
	
	Subject --|> Observer : 观测者
	Subject <|-- CurrentConditionsDisplay : 主题
	
	WeatherData -- StatisticsDisplay
    WeatherData -- ForecastDisplay
    WeatherData -- ThirdPartyDisplay
```

#### 实现观察者模式（主题推送信息）

<code-group>
  <code-block title="主题（Subject）" active>
  ```java
  import java.util.ArrayList;
  import java.util.List;
  
  interface Subject{
      void registerObserver(Observer observer);
      void removeObserver(Observer observer);
      void notifyObservers();
  }
  
  public class WeatherData implements Subject {
      private float tempreature;
      private float humidity;
      private float pressure;
      private List<Observer> listObject;
  
      public WeatherData() {
          // 创建主题对象时，实例化存储观察者的集合
          listObject = new ArrayList<>();
      }
  
      public float getTempreature() {
          return tempreature;
      }
  
      public float getHumidity() {
          return humidity;
      }
  
      public float getPressure() {
          return pressure;
      }
  
      @Override
      public void registerObserver(Observer observer) {
          // 观察者注册，将其加入通知队列中
          listObject.add(observer);
      }
  
      @Override
      public void removeObserver(Observer observer) {
          // 观察者取消，将其从通知队列中删除
          listObject.remove(observer);
      }
  
      @Override
      public void notifyObservers() {
          System.out.println("观察者数量：" + listObject.size());
          // 遍历观察者集合，发送最新观测值
          for (Observer observer : listObject) {
              observer.update(getTempreature(), getHumidity(), getPressure());
          }
      }
  
      public void measurementsChanged() {
          // 当从气象站获取更新观测值时，通知观察者
          notifyObservers();
      }
  
      public void setMeasurements(float tempreature, float humidity, float pressure) {
          this.tempreature = tempreature;
          this.humidity = humidity;
          this.pressure = pressure;
          measurementsChanged();
      }
  }
  ```
  </code-block>
  
  <code-block title="观察者（Observer）">
  ```java
  public interface Observer {
      void update(float tempreature, float humidity, float pressure);
  }
  public interface DisplayElement {
      void display();
  }
  public class CurrentConditionsDisplay implements DisplayElement, Observer{
      private float tempreature;
      private float humidity;
      private float pressure;
      private Subject subject;
  
      public CurrentConditionsDisplay(Subject s) {
          this.subject = s;
          subject.registerObserver(this);
      }
  
      @Override
      public String toString() {
          return "CurrentConditionsDisplay{" +
                  "tempreature=" + tempreature +
                  ", humidity=" + humidity +
                  ", pressure=" + pressure +
                  '}';
      }
  
      @Override
      public void update(float tempreature, float humidity, float pressure) {
          this.tempreature = tempreature;
          this.humidity = humidity;
          this.pressure = pressure;
          display();
      }
  
      @Override
      public void display() {
          System.out.println(toString());
      }
  }
  // 其他观察者类似
  ```
  </code-block>
  
  <code-block title="启动类">
  ```java
  public class Main {
      public static void main(String[] args) {
          WeatherData weatherData = new WeatherData();
  
          Observer currentConditionsDisplay = new CurrentConditionsDisplay(weatherData);
          Observer statisticsDisplay = new StatisticsDisplay(weatherData);
          Observer thirdPartyDisplay = new ThirdPartyDisplay(weatherData);
          Observer forecastDisplay = new ForecastDisplay(weatherData);
          weatherData.registerObserver(forecastDisplay);
          // weatherData.removeObserver(currentConditionsDisplay);
  
          weatherData.setMeasurements(22, 22, 22);
          weatherData.setMeasurements(25, 25, 25);
          weatherData.setMeasurements(30, 30, 30);
      }
  }
  ```
  </code-block>
</code-group>


#### 使用内置观察者模式实现主题推送数据

<code-group>
  <code-block title="主题（Subject）" active>
  ```java
  // 1. 导入java内置包
  import java.util.Observable;
  
  // 2.继承主题类
  public class Weather extends Observable {
  
      // 3. 不需要追踪观察者，父类已经实现
      // 4. 不需要构造器初始化观察者集合
      public Weather() {}
  
      public void setMeasurements(Object arg) {
          // 5. 调用 notifyObservers() 之前，调用 setChanged() 设置状态（这一步必须做，因为 changed 默认为 false ）
          setChanged();
          // 注意：传入数据参数，观察模式为主题推送；若没有传送数据对象，则为观察者拉取？
          notifyObservers(arg);
      }
  }
  ```
  </code-block>
  
  <code-block title="观察者（Observer）">
  ```java
  import java.util.List;
  import java.util.Observable;
  import java.util.Observer;
  
  public class ThirdPartyDisplay implements DisplayElement, Observer{
      private float tempreature;
      private float humidity;
      private float pressure;
      private Observable observable;
  
      public ThirdPartyDisplay(Observable weather) {
          this.observable = weather;
          this.observable.addObserver(this);
      }
  
      @Override
      public String toString() {
          return "ThirdPartyDisplay{" +
                  "tempreature=" + tempreature +
                  ", humidity=" + humidity +
                  ", pressure=" + pressure +
                  '}';
      }
  
      @Override
      public void display() {
          System.out.println(toString());
      }
  
      @Override
      public void update(Observable o, Object arg) {
          List list = (List) arg;
          this.tempreature = (float) list.get(0);
          this.humidity = (float) list.get(1);
          this.pressure = (float) list.get(2);
          display();
      }
  }
  ```
  </code-block>
  
  <code-block title="启动类">
  ```java
  import java.util.Arrays;
  import java.util.Observer;
  
  public class Main {
      public static void main(String[] args) {
          // 使用内置观察者模式实现 推送数据
          Weather weather = new Weather();
          Observer thirdPartyDisplay = new ThirdPartyDisplay(weather);
          Observer thirdPartyDisplay2 = new ThirdPartyDisplay(weather);
          weather.setMeasurements(Arrays.asList(25f, 25f, 25f));
      }
  }
  ```
  </code-block>
</code-group>

#### 使用内置观察者模式实现观察者拉取数据

<code-group>
  <code-block title="主题（Subject）" active>
  ```java
  // 1. 导入java内置包
  import java.util.Observable;
  
  // 2.继承主题类
  public class Weather extends Observable {
  
      private float tempreature;
      private float humidity;
      private float pressure;
  
      public float getTempreature() {
          return tempreature;
      }
  
      public float getHumidity() {
          return humidity;
      }
  
      public float getPressure() {
          return pressure;
      }
  
      // 3. 不需要追踪观察者，父类已经实现
      // 4. 不需要构造器初始化观察者集合
      public Weather() {}
  
      public void setMeasurements(float v, float v1, float v2) {
          this.tempreature = v;
          this.humidity = v1;
          this.pressure = v2;
          measurementsChanged();
      }
      public void measurementsChanged() {
          // 5. 调用 notifyObservers() 之前，调用 setChanged() 设置状态（这一步必须做，因为 changed 默认为 false ）
          setChanged();
          // 注意：没有传送数据对象，则为观察者拉取
          notifyObservers();
      }
  
  }
  ```
  </code-block>
  
  <code-block title="观察者（Observer）">
  ```java
  import java.util.Observable;
  import java.util.Observer;
  
  public class ThirdPartyDisplay implements DisplayElement, Observer{
      private float tempreature;
      private float humidity;
      private float pressure;
      private Observable observable;
  
      public ThirdPartyDisplay(Observable weather) {
          this.observable = weather;
          this.observable.addObserver(this);
      }
  
      @Override
      public String toString() {
          return "ThirdPartyDisplay{" +
                  "tempreature=" + tempreature +
                  ", humidity=" + humidity +
                  ", pressure=" + pressure +
                  '}';
      }
  
      @Override
      public void display() {
          System.out.println(toString());
      }
  
      @Override
      public void update(Observable o, Object arg) {
          if (o instanceof Weather) {
              Weather weather = (Weather) o;
              this.tempreature = weather.getTempreature();
              this.humidity = weather.getHumidity();
              this.pressure = weather.getPressure();
              display();
          }
      }
  }
  ```
  </code-block>
  
  <code-block title="启动类">
  ```java
  
  import java.util.Observer;
  
  public class Main {
      public static void main(String[] args) {
          // 使用内置观察者模式实现观察者拉取数据
          Weather weather = new Weather();
          Observer thirdPartyDisplay1 = new ThirdPartyDisplay(weather);
          Observer thirdPartyDisplay2 = new ThirdPartyDisplay(weather);
          weather.setMeasurements(25f, 25f, 25f);
      }
  }
  ```
  </code-block>
</code-group>

#### 要点

- 观察者模式定义了对象之间一对多的关系。
- 主题（也就是可观察者）用一个共同的接口来更新观察者
- 观察者和可观察者之间用松耦合方式结合（loosecoupling),可观察者不知道观察者的细节，只知道观察者实现了观察者接口。
- 使用此模式时，你可从被观察者处推(push)或拉(pull)数据（然而，推的方式被认为更“正确”）。
- 有多个观察者时，不可以依赖特定的通知次序。
- Java有多种观察者模式的实现，包括了通用的java.util.Observable
- 要注意 java.util.Observable 实现上所带来的一些问题。
- 如果有必要的话，可以实现自己的Observable，这并不难，不要害怕。
- Swing大量使用观察者模式，许多GUI框架也是如此。
- 此模式也被应用在许多地方，例如：JavaBeans、RMI。

#### 观察者模式对设计原则的应用

1. 找出程序中会变化的方面，然后将其和固定不变的方面相分离。
> 在观察者模式中，会改变的是主题的状态，以及观察者的数目和类型。用这个模式，你可以改变依赖于主题状态的对象，却不必改变主题。这就叫提前规划！
2. 针对接口编程，不针对实现编程。
> 主题与观察者都使用接口：观察者利用主题的接口向主题注册，而主题利用观察者接口通知观察者。这样可以让两者之间运作正常，又同时具有松耦合的优点。
3. 多用组合，少用继承。
> 观察者模式利用“组合”，将许多观察者组合进主题中。对象之间的这种关系不是通过继承产生的，而是在运行时利用组合的方式而产生的。

## mermaid 语法

---

#### Github官网

**Mermaid 是一个基于 JavaScript 的图表和图表工具，通过解析 Markdown 的文本定义，以动态创建和修改图表。**

可使之创建流程图、时序图、UML类图、状态图、实体关系图、用户体验旅程图、甘特图、饼图、需求图、Git分支图、软件架构（C4）图等

[官网语法](https://mermaid-js.github.io/mermaid)

